<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Ruby on Rails Guides: The Rails Initialization Process</title>

<link rel="stylesheet" type="text/css" href="stylesheets/style.css" />
<link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />

<link rel="stylesheet" type="text/css" href="stylesheets/syntaxhighlighter/shCore.css" />
<link rel="stylesheet" type="text/css" href="stylesheets/syntaxhighlighter/shThemeRailsGuides.css" />
</head>
<body class="guide">
  <div id="topNav">
    <div class="wrapper">
      <strong>More at <a href="http://rubyonrails.org/">rubyonrails.org:</a> </strong>
      <a href="http://rubyonrails.org/">Overview</a> |
      <a href="http://rubyonrails.org/download">Download</a> |
      <a href="http://rubyonrails.org/deploy">Deploy</a> |
      <a href="http://rails.lighthouseapp.com/projects/8994-ruby-on-rails/overview">Code</a> |
      <a href="http://rubyonrails.org/screencasts">Screencasts</a> |
      <a href="http://rubyonrails.org/documentation">Documentation</a> |
      <a href="http://rubyonrails.org/ecosystem">Ecosystem</a> |
      <a href="http://rubyonrails.org/community">Community</a> |
      <a href="http://weblog.rubyonrails.org/">Blog</a>
    </div>
  </div>
  <div id="header">
    <div class="wrapper clearfix">
      <h1><a href="index.html" title="Return to home page">Guides.rubyonrails.org</a></h1>
      <p class="hide"><a href="#mainCol">Skip navigation</a>.</p>
      <ul class="nav">
        <li><a href="index.html">Home</a></li>
        <li class="index"><a href="index.html" onclick="guideMenu(); return false;" id="guidesMenu">Guides Index</a>
          <div id="guides" class="clearfix" style="display: none;">
            <hr />
            <dl class="L">
              <dt>Start Here</dt>
              <dd><a href="getting_started.html">Getting Started with Rails</a></dd>
              <dt>Models</dt>
              <dd><a href="migrations.html">Rails Database Migrations</a></dd>
              <dd><a href="active_record_validations_callbacks.html">Active Record Validations and Callbacks</a></dd>
              <dd><a href="association_basics.html">Active Record Associations</a></dd>
              <dd><a href="active_record_querying.html">Active Record Query Interface</a></dd>
              <dt>Views</dt>
              <dd><a href="layouts_and_rendering.html">Layouts and Rendering in Rails</a></dd>
              <dd><a href="form_helpers.html">Action View Form Helpers</a></dd>
              <dt>Controllers</dt>
              <dd><a href="action_controller_overview.html">Action Controller Overview</a></dd>
              <dd><a href="routing.html">Rails Routing from the Outside In</a></dd>
            </dl>
            <dl class="R">
              <dt>Digging Deeper</dt>
              <dd><a href="active_support_core_extensions.html">Active Support Core Extensions</a></dd>
              <dd><a href="i18n.html">Rails Internationalization API</a></dd>
              <dd><a href="action_mailer_basics.html">Action Mailer Basics</a></dd>
              <dd><a href="testing.html">Testing Rails Applications</a></dd>
              <dd><a href="security.html">Securing Rails Applications</a></dd>
              <dd><a href="debugging_rails_applications.html">Debugging Rails Applications</a></dd>
              <dd><a href="performance_testing.html">Performance Testing Rails Applications</a></dd>
              <dd><a href="configuring.html">Configuring Rails Applications</a></dd>
              <dd><a href="command_line.html">Rails Command Line Tools and Rake Tasks</a></dd>
              <dd><a href="caching_with_rails.html">Caching with Rails</a></dd>

              <dt>Extending Rails</dt>
              <dd><a href="plugins.html">The Basics of Creating Rails Plugins</a></dd>
              <dd><a href="rails_on_rack.html">Rails on Rack</a></dd>
              <dd><a href="generators.html">Creating and Customizing Rails Generators</a></dd>

              <dt>Contributing to Ruby on Rails</dt>
              <dd><a href="contributing_to_ruby_on_rails.html">Contributing to Ruby on Rails</a></dd>
              <dd><a href="api_documentation_guidelines.html">API Documentation Guidelines</a></dd>
              <dd><a href="ruby_on_rails_guides_guidelines.html">Ruby on Rails Guides Guidelines</a></dd>

              <dt>Release Notes</dt>
              <dd><a href="3_0_release_notes.html">Ruby on Rails 3.0 Release Notes</a></dd>
              <dd><a href="2_3_release_notes.html">Ruby on Rails 2.3 Release Notes</a></dd>
              <dd><a href="2_2_release_notes.html">Ruby on Rails 2.2 Release Notes</a></dd>
            </dl>
          </div>
        </li>
        <li><a href="contribute.html">Contribute</a></li>
        <li><a href="credits.html">Credits</a></li>
      </ul>
    </div>
  </div>
  <hr class="hide" />

  <div id="feature">
    <div class="wrapper">
      <h2>The Rails Initialization Process</h2>
<p>This guide explains how the initialization process in Rails works as of Rails 3.</p>
<ul>
	<li>Using <tt>rails server</tt></li>
	<li>Using Passenger</li>
</ul>

            <div id="subCol">
        <h3 class="chapter"><img src="images/chapters_icon.gif" alt="" />Chapters</h3>
        <ol class="chapters">
<li><a href="#launch">Launch!</a></li><li><a href="#passenger">Passenger</a></li><li><a href="#_config-boot-rb_"><em>config/boot.rb</em></a></li><li><a href="#bundled-rails-3-x">Bundled Rails (3.x)</a></li><li><a href="#requiring-rails">Requiring Rails</a><ul><li><a href="#require-active_support"><tt>require 'active_support'</tt></a></li> <li><a href="#lazy-hooks">Lazy Hooks</a></li> <li><a href="#require-active_support-cont-d"><tt>require 'active_support'</tt> cont&#8217;d.</a></li> <li><a href="#require-action_dispatch"><tt>require 'action_dispatch'</tt></a></li> <li><a href="#require-rails-commands-server"><tt>require "rails/commands/server"</tt></a></li> <li><a href="#require-rails-commands"><tt>require "rails/commands"</tt></a></li> <li><a href="#require-app_path"><tt>require APP_PATH</tt></a></li> <li><a href="#require-rails-all"><tt>require "rails/all"</tt></a></li> <li><a href="#require-rails"><tt>require 'rails'</tt></a></li> <li><a href="#require-active_support-core_ext-kernel-reporting"><tt>require 'active_support/core_ext/kernel/reporting'</tt></a></li> <li><a href="#require-active_support-core_ext-logger"><tt>require 'active_support/core_ext/logger'</tt></a></li> <li><a href="#require-rails-application"><tt>require 'rails/application'</tt></a></li> <li><a href="#require-rails-railties_path"><tt>require 'rails/railties_path'</tt></a></li> <li><a href="#require-rails-plugin"><tt>require 'rails/plugin'</tt></a></li> <li><a href="#require-rails-engine"><tt>require 'rails/engine'</tt></a></li> <li><a href="#require-rails-railtie"><tt>require 'rails/railtie'</tt></a></li> <li><a href="#require-rails-initializable"><tt>require 'rails/initializable'</tt></a></li> <li><a href="#require-rails-configuration"><tt>require 'rails/configuration'</tt></a></li> <li><a href="#require-active_support-ordered_options"><tt>require 'active_support/ordered_options'</tt></a></li> <li><a href="#require-rails-paths"><tt>require 'rails/paths'</tt></a></li> <li><a href="#require-rails-rack"><tt>require 'rails/rack'</tt></a></li> <li><a href="#require-rails-version"><tt>require 'rails/version'</tt></a></li> <li><a href="#require-rails-deprecation"><tt>require 'rails/deprecation'</tt></a></li> <li><a href="#require-rails-log_subscriber"><tt>require 'rails/log_subscriber'</tt></a></li> <li><a href="#require-rails-ruby_version_check"><tt>require 'rails/ruby_version_check'</tt></a></li> <li><a href="#require-activesupport-railtie"><tt>require 'activesupport/railtie'</tt></a></li> <li><a href="#require-action_dispatch-railtie"><tt>require 'action_dispatch/railtie'</tt></a></li> <li><a href="#return-to-_rails-all-rb_">Return to <em>rails/all.rb</em></a></li> <li><a href="#activesupport-railtie">ActiveSupport Railtie</a></li> <li><a href="#active-record-railtie">Active Record Railtie</a></li> <li><a href="#active-model-railtie">Active Model Railtie</a></li> <li><a href="#action-controller-railtie">Action Controller Railtie</a></li> <li><a href="#action-view-railtie">Action View Railtie</a></li> <li><a href="#action-mailer-railtie">Action Mailer Railtie</a></li> <li><a href="#active-resource-railtie">Active Resource Railtie</a></li> <li><a href="#actiondispatch-railtie">ActionDispatch Railtie</a></li></ul></li><li><a href="#return-to-_config-application-rb_">Return to <em>config/application.rb</em></a></li><li><a href="#return-to-rails">Return to Rails</a></li><li><a href="#firing-it-up">Firing it up!</a></li><li><a href="#racking-it-up">Racking it up!</a></li><li><a href="#_config-environment-rb_"><em>config/environment.rb</em></a></li><li><a href="#rails-initialization-process">Rails Initialization Process</a></li><li><a href="#rails-application"><tt>Rails::Application</tt></a></li><li><a href="#your-application-s-configuration">Your Application&#8217;s Configuration</a></li><li><a href="#rails-configuration-shared"><tt>Rails::Configuration::Shared</tt></a></li><li><a href="#application-configured">Application Configured!</a></li><li><a href="#initialization-begins">Initialization begins</a></li><li><a href="#run_initializers"><tt>run_initializers</tt></a></li><li><a href="#bootstrap-initializers"><tt>Bootstrap</tt> initializers</a></li><li><a href="#railties-initializers">Railties Initializers</a></li><li><a href="#engine-initializers">Engine Initializers</a></li><li><a href="#finisher-initializers">Finisher Initializers</a></li><li><a href="#running-the-initializers">Running the Initializers</a></li><li><a href="#bootstrap-initializers">Bootstrap Initializers</a><ul><li><a href="#load_environment_config"><tt>load_environment_config</tt></a></li> <li><a href="#load_all_active_support"><tt>load_all_active_support</tt></a></li> <li><a href="#preload_frameworks"><tt>preload_frameworks</tt></a></li> <li><a href="#active-support-initializers">Active Support Initializers</a></li> <li><a href="#rails-engine-new"><tt>Rails::Engine.new</tt></a></li> <li><a href="#rails-application-require_environment"><tt>Rails::Application#require_environment</tt></a></li> <li><a href="#rails-application-config"><tt>Rails::Application.config</tt></a></li> <li><a href="#rails-plugin-configuration-default"><tt>Rails::Plugin::Configuration.default</tt></a></li> <li><a href="#rails-railtie-configuration"><tt>Rails::Railtie::Configuration</tt></a></li> <li><a href="#rails-application-configuration-new"><tt>Rails::Application::Configuration.new</tt></a></li> <li><a href="#default_middleware_stack"><tt>default_middleware_stack</tt></a></li> <li><a href="#actiondispatch-middlewarestack-new"><tt>ActionDispatch::MiddlewareStack.new</tt></a></li> <li><a href="#actiondispatch-middlewarestack-use"><tt>ActionDispatch::MiddlewareStack.use</tt></a></li> <li><a href="#actioncontroller-middleware-new"><tt>ActionController::Middleware.new</tt></a></li> <li><a href="#actioncontroller-metal-initialize"><tt>ActionController::Metal.initialize</tt></a></li> <li><a href="#abstractcontroller-base-initialize"><tt>AbstractController::Base.initialize</tt></a></li> <li><a href="#back-to-rails-application-configuration-new">Back to <tt>Rails::Application::Configuration.new</tt></a></li> <li><a href="#back-to-rails-application-require_environment">Back to <tt>Rails::Application#require_environment</tt></a></li> <li><a href="#_config-environments-development-rb_"><em>config/environments/development.rb</em></a></li></ul></li><li><a href="#serving-a-request">Serving a Request</a><ul><li><a href="#_rails-server_"><em>rails server</em></a></li></ul></li><li><a href="#cruft">Cruft!</a></li><li><a href="#rails-paths"><tt>Rails::Paths</tt></a></li><li><a href="#appendix-a">Appendix A</a></li><li><a href="#common-includes">Common Includes</a><ul><li><a href="#require-active_support-inflector"><tt>require 'active_support/inflector'</tt></a></li> <li><a href="#require-active_support-core_ext-module-delegation"><tt>require 'active_support/core_ext/module/delegation'</tt></a></li> <li><a href="#require-active_support-core_ext-class-attribute_accessors"><tt>require 'active_support/core_ext/class/attribute_accessors'</tt></a></li> <li><a href="#require-active_support-core_ext-module-attr_internal"><tt>require 'active_support/core_ext/module/attr_internal</tt></a></li> <li><a href="#require-active_support-ruby-shim"><tt>require 'active_support/ruby/shim'</tt></a></li></ul></li></ol></div>
    </div>
  </div>

  <div id="container">
    <div class="wrapper">
      <div id="mainCol">
        <p>This guide first describes the process of <tt>rails server</tt> then explains the Passenger + Rack method, before delving into the common initialize pattern these two go through.</p>
<h3 id="launch">1 Launch!</h3>
<p>As of Rails 3, <tt>script/server</tt> has become <tt>rails server</tt>. This was done to centralize all rails related commands to one common file.</p>
<p>The actual <tt>rails</tt> command is kept in <em>railties/bin/rails</em> and goes like this:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require 'rbconfig'

  module Rails
    module ScriptRailsLoader
      RUBY = File.join(*RbConfig::CONFIG.values_at(&quot;bindir&quot;, &quot;ruby_install_name&quot;)) + RbConfig::CONFIG[&quot;EXEEXT&quot;]
      SCRIPT_RAILS = File.join('script', 'rails')

      def self.exec_script_rails!
        cwd = Dir.pwd
        exec RUBY, SCRIPT_RAILS, *ARGV if File.exists?(SCRIPT_RAILS)
        Dir.chdir(&quot;..&quot;) do
          # Recurse in a chdir block: if the search fails we want to be sure
          # the application is generated in the original working directory.
          exec_script_rails! unless cwd == Dir.pwd
        end
      rescue SystemCallError
        # could not chdir, no problem just return
      end
    end
  end

  Rails::ScriptRailsLoader.exec_script_rails!

  railties_path = File.expand_path('../../lib', __FILE__)
  $:.unshift(railties_path) if File.directory?(railties_path) &amp;&amp; !$:.include?(railties_path)

  require 'rails/ruby_version_check'
  Signal.trap(&quot;INT&quot;) { puts; exit }

  require 'rails/commands/application'
</pre>
</div>
</notextile>

<p>The <tt>Rails::ScriptRailsLoader</tt> module here defines two constants: <tt>RUBY</tt> and <tt>SCRIPT_RAILS</tt>. <tt>RUBY</tt> is the full path to your ruby executable, on a Snow Leopard system it&#8217;s <em>/System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/bin/ruby_. <tt><span class="caps">SCRIPT</span></em><span class="caps">RAILS</span></tt></notextile> is simply <em>script/rails_. When <tt>exec_script</em>rails</tt></notextile> is invoked, this will attempt to <tt>exec</tt> the <em>rails</em> file in the <em>script</em> directory using the path to your Ruby executable, <tt>RUBY</tt>. If <tt>exec</tt> is invoked, the program will stop at this point. If the <em>script/rails</em> file doesn&#8217;t exist in the current directory, Rails will recurse upwards until it finds it by calling <tt>exec_script_rails</tt> from inside the <tt>Dir.chdir("..")</tt>. This is handy if you&#8217;re currently in one of the sub-directories of the rails application and wish to launch a server or a console.</p>
<p>If Rails cannot execute <em>script/rails</em> then it will fall back to the standard <tt>rails</tt> command task of generating an application.</p>
<p>In <tt>script/rails</tt> we see the following:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
#!/usr/bin/env ruby
  # This command will automatically be run when you run &quot;rails&quot; with Rails 3 gems installed from the root of your application.

  APP_PATH = File.expand_path('../../config/application',  __FILE__)
  require File.expand_path('../../config/boot',  __FILE__)
  require 'rails/commands'
</pre>
</div>
</notextile>

<p>This obviously defines a couple of constants to some pretty important files, <em>config/environment.rb</em>, <em>config/boot.rb</em> and <em>config/application.rb</em> all within the context of <tt>__FILE__</tt> which is of course <tt>script/rails</tt> in the root of your application. Then it goes on to <tt>require BOOT_PATH</tt> which leads us onto <em>config/boot.rb</em>.</p>
<h3 id="passenger">2 Passenger</h3>
<p>Before we dive into what <em>config/boot.rb</em> encompasses, we&#8217;ll just glimpse at what Passenger does enough to get an understanding of how it requires a Rails application.</p>
<p>Passenger will require <em>config/environment.rb</em> by way of its <tt>PhusionPassenger::Railz::ApplicationSpawner#preload_application</tt> method. <em>config/environment.rb</em> requires <em>config/application.rb</em> which requires <em>config/boot.rb</em>. That&#8217;s how the Rails boot process begins with Passenger in a nutshell.</p>
<h3 id="_config-boot-rb_">3 <em>config/boot.rb</em></h3>
<p><em>config/boot.rb</em> is the first stop for everything for initializing your application. This boot process does quite a bit of work for you and so this section attempts to go in-depth enough to explain what each of the pieces does.</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require 'rubygems'

  # Set up gems listed in the Gemfile.
  gemfile = File.expand_path('../../Gemfile', __FILE__)
  begin
    ENV['BUNDLE_GEMFILE'] = gemfile
    require 'bundler'
    Bundler.setup
  rescue Bundler::GemNotFound =&gt; e
    STDERR.puts e.message
    STDERR.puts &quot;Try running `bundle install`.&quot;
    exit!
  end if File.exist?(gemfile)
</pre>
</div>
</notextile>

<h3 id="bundled-rails-3-x">4 Bundled Rails (3.x)</h3>
<p>Rails 3 now uses Bundler and the <span class="caps">README</span> for the project explains it better than I could:</p>
<p>&gt; &#8220;Bundler is a tool that manages gem dependencies for your ruby application. It takes a gem manifest file and is able to fetch, download, and install the gems and all child dependencies specified in this manifest. It can manage any update to the gem manifest file and update the bundle&#8217;s gems accordingly. It also lets you run any ruby code in context of the bundle&#8217;s gem environment.&#8221;</p>
<p>Now with Rails 3 we have a Gemfile which defines the basics our application needs to get going:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
source 'http://rubygems.org'

  gem 'rails', '3.0.0'

  # Bundle edge Rails instead:
  # gem 'rails', :git =&gt; 'git://github.com/rails/rails.git'

  gem 'sqlite3'

  # Use unicorn as the web server
  # gem 'unicorn'

  # Deploy with Capistrano
  # gem 'capistrano'

  # Bundle the extra gems:
  # gem 'bj'
  # gem 'nokogiri'
  # gem 'sqlite3'
  # gem 'aws-s3', :require =&gt; 'aws/s3'

  # Bundle gems for certain environments:
  # gem 'rspec', :group =&gt; :test
  # group :test do
  #   gem 'webrat'
  # end
</pre>
</div>
</notextile>

<p>Here the only two gems we need are <tt>rails</tt> and <tt>sqlite3</tt>, so it seems. This is until you run <tt>bundle pack</tt>. This command freezes all the gems required by your application into <em>vendor/cache</em>. The gems installed by default are:</p>
<ul>
	<li>abstract-1.0.0.gem</li>
	<li>actionmailer-3.0.0.gem</li>
	<li>actionpack-3.0.0.gem</li>
	<li>activemodel-3.0.0.gem</li>
	<li>activerecord-3.0.0.gem</li>
	<li>activeresource-3.0.0.gem</li>
	<li>activesupport-3.0.0.gem</li>
	<li>arel-0.4.0.gem</li>
	<li>builder-2.1.2.gem</li>
	<li>bundler-1.0.0.gem</li>
	<li>erubis-2.6.6.gem</li>
	<li>i18n-0.4.1.gem</li>
	<li>mail-2.2.5.gem</li>
	<li>memcache-client-1.8.5.gem</li>
	<li>mime-types-1.16.gem</li>
	<li>nokogiri-1.4.3.1.gem</li>
	<li>polyglot-0.3.1.gem</li>
	<li>rack-1.2.1.gem</li>
	<li>rack-mount-0.6.12.gem</li>
	<li>rack-test-0.5.4.gem</li>
	<li>rails-3.0.0.gem</li>
	<li>railties-3.0.0.gem</li>
	<li>rake-0.8.7.gem</li>
	<li>sqlite3-1.3.3.gem</li>
	<li>text-format-1.0.0.gem</li>
	<li>text-hyphen-1.0.0.gem</li>
	<li>thor-0.13.7.gem</li>
	<li>treetop-1.4.8.gem</li>
	<li>tzinfo-0.3.23.gem</li>
</ul>
<p><span class="caps">TODO</span>: Prettify when it becomes more stable.</p>
<p>I won&#8217;t go into what each of these gems are, as that is really something that needs covering on a case-by-case basis. We will however just dig a little under the surface of Bundler.</p>
<p>Back in <em>config/boot.rb</em>, we call <tt>Bundler.setup</tt> which will load and parse the <tt>Gemfile</tt> and add the <em>lib</em> directory of the gems mentioned <b>and</b> their dependencies (<b>and</b> their dependencies&#8217; dependencies, and so on) to the <tt>$LOAD_PATH</tt>.</p>
<h3 id="requiring-rails">5 Requiring Rails</h3>
<p>After <em>config/boot.rb</em> is loaded, there&#8217;s this <tt>require</tt>:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require 'rails/commands'
</pre>
</div>
</notextile>

<p>In this file, <em>railties/lib/rails/commands.rb</em>, there is a case statement for <tt>ARGV.shift</tt>:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
case ARGV.shift
  ...
  when 's', 'server'
    require 'rails/commands/server'
    # Initialize the server first, so environment options are set
    server = Rails::Server.new
    require APP_PATH
  ...
  end
</pre>
</div>
</notextile>

<p>We&#8217;re running <tt>rails server</tt> and this means it will make a require out to <em>rails/commands/server</em> (<em>railties/lib/rails/commands/server.rb</em>). Firstly, this file makes a couple of requires of its own:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require 'fileutils'
  require 'optparse'
  require 'action_dispatch'
</pre>
</div>
</notextile>

<p>The first two are Ruby core and this guide does not cover what they do, but <em>action_dispatch</em> (<em>actionpack/lib/action_dispatch.rb</em>) is important. This file firstly make a require to <em>active_support</em> (<em>activesupport/lib/active_support.rb</em>) which defines the <tt>ActiveSupport</tt> module.</p>
<h4 id="require-active_support">5.1 <tt>require 'active_support'</tt></h4>
<p><em>activesupport/lib/active_support.rb</em> sets up <tt>module ActiveSupport</tt>:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
module ActiveSupport
    class &lt;&lt; self
      attr_accessor :load_all_hooks
      def on_load_all(&amp;hook) load_all_hooks &lt;&lt; hook end
      def load_all!; load_all_hooks.each { |hook| hook.call } end
    end
    self.load_all_hooks = []

    on_load_all do
      [Dependencies, Deprecation, Gzip, MessageVerifier, Multibyte, SecureRandom]
    end
  end
</pre>
</div>
</notextile>

<p>This defines two methods on the module itself by using the familiar <tt>class << self</tt> syntax. This allows you to call them as if they were class methods: <tt>ActiveSupport.on_load_all</tt> and <tt>ActiveSupport.load_all!</tt> respectively. The first method simply adds loading hooks to save them up for loading later on when <tt>load_all!</tt> is called. By <tt>call</tt>&#8217;ing the block, the classes will be loaded. (<span class="caps">NOTE</span>: kind of guessing, I feel 55% about this).</p>
<p>The <tt>on_load_all</tt> method is called later with the <tt>Dependencies</tt>, <tt>Deprecation</tt>, <tt>Gzip</tt>, <tt>MessageVerifier</tt>, <tt>Multibyte</tt> and <tt>SecureRandom</tt>. What each of these modules do will be covered later.</p>
<p>This file goes on to define some classes that will be automatically loaded using Ruby&#8217;s <tt>autoload</tt> method, but not before including Rails&#8217;s own variant of the <tt>autoload</tt> method from <em>active_support/dependencies/autoload.rb</em>:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require &quot;active_support/inflector/methods&quot;
  require &quot;active_support/lazy_load_hooks&quot;

  module ActiveSupport
    module Autoload
      def self.extended(base)
        base.extend(LazyLoadHooks)
      end

      @@autoloads = {}
      @@under_path = nil
      @@at_path = nil
      @@eager_autoload = false

      def autoload(const_name, path = @@at_path)
        full = [self.name, @@under_path, const_name.to_s, path].compact.join(&quot;::&quot;)
        location = path || Inflector.underscore(full)

        if @@eager_autoload
          @@autoloads[const_name] = location
        end
        super const_name, location
      end

      ...
    end
  end
</pre>
</div>
</notextile>

<h4 id="lazy-hooks">5.2 Lazy Hooks</h4>
<p><tt>ActiveSupport::LazyLoadHooks</tt> is responsible for defining methods used for running hooks that are defined during the initialization process, such as the one defined inside the <tt>active_record.initialize_timezone</tt> initializer:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
initializer &quot;active_record.initialize_timezone&quot; do
    ActiveSupport.on_load(:active_record) do
      self.time_zone_aware_attributes = true
      self.default_timezone = :utc
    end
  end
</pre>
</div>
</notextile>

<p>When the initializer runs it invokes method <tt>on_load</tt> for <tt>ActiveRecord</tt> and the block passed to it would be called only when <tt>run_load_hooks</tt> is called.
When the entirety of <tt>activerecord/lib/active_record/base.rb</tt> has been evaluated then <tt>run_load_hooks</tt> is invoked. The very last line of <tt>activerecord/lib/active_record/base.rb</tt> is:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
ActiveSupport.run_load_hooks(:active_record, ActiveRecord::Base)
</pre>
</div>
</notextile>

<h4 id="require-active_support-cont-d">5.3 <tt>require 'active_support'</tt> cont&#8217;d.</h4>
<p>This file also uses the method <tt>eager_autoload</tt> also defined in <em>active_support/dependencies/autoload.rb</em>:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def eager_autoload
    old_eager, @@eager_autoload = @@eager_autoload, true
    yield
  ensure
    @@eager_autoload = old_eager
  end
</pre>
</div>
</notextile>

<p>As you can see for the duration of the <tt>eager_autoload</tt> block the class variable <tt>@@eager_autoload</tt> is set to <tt>true</tt>, which has the consequence of when <tt>autoload</tt> is called that the location of the file for that specific <tt>autoload</tt>&#8216;d constant is added to the <tt>@@autoloads</tt> hash initialized at the beginning of this module declaration. So now that you have part of the context, here&#8217;s the other, the code from <em>activesupport/lib/active_support.rb</em>:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require &quot;active_support/dependencies/autoload&quot;

  module ActiveSupport
    extend ActiveSupport::Autoload

    autoload :DescendantsTracker
    autoload :FileUpdateChecker
    autoload :LogSubscriber
    autoload :Notifications

    # TODO: Narrow this list down
    eager_autoload do
      autoload :BacktraceCleaner
      autoload :Base64
      autoload :BasicObject
      autoload :Benchmarkable
      autoload :BufferedLogger
      autoload :Cache
      autoload :Callbacks
      autoload :Concern
      autoload :Configurable
      autoload :Deprecation
      autoload :Gzip
      autoload :Inflector
      autoload :JSON
      autoload :Memoizable
      autoload :MessageEncryptor
      autoload :MessageVerifier
      autoload :Multibyte
      autoload :OptionMerger
      autoload :OrderedHash
      autoload :OrderedOptions
      autoload :Rescuable
      autoload :SecureRandom
      autoload :StringInquirer
      autoload :XmlMini
    end

    autoload :SafeBuffer, &quot;active_support/core_ext/string/output_safety&quot;
    autoload :TestCase
  end

  autoload :I18n, &quot;active_support/i18n&quot;
</pre>
</div>
</notextile>

<p>So we know the ones in <tt>eager_autoload</tt> are eagerly loaded and it does this by storing them in an <tt>@@autoloads</tt> hash object and then loading them via <tt>eager_autoload!</tt> which is called via the <tt>preload_frameworks</tt> initializer defined in <em>railties/lib/rails/application/bootstrap.rb</em>.</p>
<p>The classes and modules that are not <tt>eager_autoload</tt>&#8217;d are automatically loaded as they are references</p>
<p>Note: What does it means to be autoloaded? An example of this would be calling the <tt>ActiveSupport::TestCase</tt> class which hasn&#8217;t yet been initialized. Because it&#8217;s been specified as an <tt>autoload</tt> Ruby will require the file that it&#8217;s told to. The file it requires is not defined in the <tt>autoload</tt> call here but, as you may have seen, in the <tt>ActiveSupport::Autoload.autoload</tt> definition. So once that file has been required Ruby will try again and then if it still can&#8217;t find it it will throw the all-too-familiar <tt>uninitialized constant</tt> error.</p>
<h4 id="require-action_dispatch">5.4 <tt>require 'action_dispatch'</tt></h4>
<p>Back in <em>actionpack/lib/action_dispatch.rb</em>, the next require after <em>active_support</em> is to <em>active_support/dependencies/autoload</em> but this file has already been loaded by <em>activesupport/lib/active_support.rb</em> and so will not be loaded again. The next require is to Rack itself:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require 'rack'
</pre>
</div>
</notextile>

<p>As mentioned previously, Bundler has added the gems&#8217; <em>lib</em> directories to the load path so this <em>rack</em> file that is referenced lives in the Rack gem: <em>lib/rack.rb</em>. This loads Rack so we can use it later on when we define <tt>Rails::Server</tt> to descend from <tt>Rack::Server</tt>.</p>
<p>This file then goes on to define the <tt>ActionDispatch</tt> module and it&#8217;s related autoloads:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
module Rack
    autoload :Test, 'rack/test'
  end

  module ActionDispatch
    extend ActiveSupport::Autoload

    autoload_under 'http' do
      autoload :Request
      autoload :Response
    end

    autoload_under 'middleware' do
      autoload :Callbacks
      autoload :Cascade
      autoload :Cookies
      autoload :Flash
      autoload :Head
      autoload :ParamsParser
      autoload :RemoteIp
      autoload :Rescue
      autoload :ShowExceptions
      autoload :Static
    end

    autoload :MiddlewareStack, 'action_dispatch/middleware/stack'
    autoload :Routing

    module Http
      extend ActiveSupport::Autoload

      autoload :Cache
      autoload :Headers
      autoload :MimeNegotiation
      autoload :Parameters
      autoload :FilterParameters
      autoload :Upload
      autoload :UploadedFile, 'action_dispatch/http/upload'
      autoload :URL
    end

    module Session
      autoload :AbstractStore, 'action_dispatch/middleware/session/abstract_store'
      autoload :CookieStore,   'action_dispatch/middleware/session/cookie_store'
      autoload :MemCacheStore, 'action_dispatch/middleware/session/mem_cache_store'
    end

    autoload_under 'testing' do
      autoload :Assertions
      autoload :Integration
      autoload :PerformanceTest
      autoload :TestProcess
      autoload :TestRequest
      autoload :TestResponse
    end
  end

  autoload :Mime, 'action_dispatch/http/mime_type'
</pre>
</div>
</notextile>

<h4 id="require-rails-commands-server">5.5 <tt>require "rails/commands/server"</tt></h4>
<p>Now that Rails has required Action Dispatch and it has required Rack, Rails can now go about defining the <tt>Rails::Server</tt> class:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
module Rails
    class Server &lt; ::Rack::Server

      ...

      def initialize(*)
        super
        set_environment
      end

      ...

      def set_environment
        ENV[&quot;RAILS_ENV&quot;] ||= options[:environment]
      end
      ...
    end
  end
</pre>
</div>
</notextile>

<h4 id="require-rails-commands">5.6 <tt>require "rails/commands"</tt></h4>
<p>Back in <em>rails/commands</em> Rails calls <tt>Rails::Server.new</tt> which calls the <tt>initialize</tt> method on the <tt>Rails::Server</tt> class, which calls <tt>super</tt>, meaning it&#8217;s actually calling <tt>Rack::Server#initialize</tt>, with it being defined like this:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def initialize(options = nil)
    @options = options
  end
</pre>
</div>
</notextile>

<p>The <tt>options</tt> method like this:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def options
    @options ||= parse_options(ARGV)
  end
</pre>
</div>
</notextile>

<p>The <tt>parse_options</tt> method like this:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def parse_options(args)
    options = default_options

    # Don't evaluate CGI ISINDEX parameters.
    # http://hoohoo.ncsa.uiuc.edu/cgi/cl.html
    args.clear if ENV.include?(&quot;REQUEST_METHOD&quot;)

    options.merge! opt_parser.parse! args
    options
  end
</pre>
</div>
</notextile>

<p>And <tt>default_options</tt> like this:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def default_options
    {
      :environment =&gt; &quot;development&quot;,
      :pid         =&gt; nil,
      :Port        =&gt; 9292,
      :Host        =&gt; &quot;0.0.0.0&quot;,
      :AccessLog   =&gt; [],
      :config      =&gt; &quot;config.ru&quot;
    }
  end
</pre>
</div>
</notextile>

<p>Here it is important to note that the default environment is <em>development_. After <tt>Rack::Server#initialize</tt> has done its thing it returns to <tt>Rails::Server#initialize</tt> which calls <tt>set</em>environment</tt></notextile>:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def set_environment
    ENV[&quot;RAILS_ENV&quot;] ||= options[:environment]
  end
</pre>
</div>
</notextile>

<p>From the information given we can determine that <tt>ENV["RAILS_ENV"]</tt> will be set to <em>development</em> if no other environment is specified.</p>
<p>Finally, after <tt>Rails::Server.new</tt> has executed, there is one more require:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require APP_PATH
</pre>
</div>
</notextile>

<p><tt>APP_PATH</tt> was previously defined as <em>config/application.rb</em> in the application&#8217;s root, and so that is where Rails will go next.</p>
<h4 id="require-app_path">5.7 <tt>require APP_PATH</tt></h4>
<p>This file is <em>config/application.rb</em> in your application and makes two requires to begin with:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require File.expand_path('../boot', __FILE__)
  require 'rails/all'
</pre>
</div>
</notextile>

<p>The <tt>../boot</tt> file it references is <tt>config/boot.rb</tt>, which was loaded earlier in the initialization process and so will not be loaded again.</p>
<p>If you generate the application with the <tt>-O</tt> option this will put a couple of pick-and-choose requirements at the top of your <em>config/application.rb</em> instead:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
# Pick the frameworks you want:
  # require &quot;active_record/railtie&quot;
  require &quot;action_controller/railtie&quot;
  require &quot;action_mailer/railtie&quot;
  require &quot;active_resource/railtie&quot;
  require &quot;rails/test_unit/railtie&quot;
</pre>
</div>
</notextile>

<p>For the purposes of this guide, will will assume only:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require 'rails/all'
</pre>
</div>
</notextile>

<h4 id="require-rails-all">5.8 <tt>require "rails/all"</tt></h4>
<p>Now we&#8217;ll dive into the internals of the pre-initialization stage of Rails. The file that is being required is <em>railties/lib/rails/all.rb</em>. The first line in this file is:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require 'rails'
</pre>
</div>
</notextile>

<h4 id="require-rails">5.9 <tt>require 'rails'</tt></h4>
<p>This file (<em>railties/lib/rails.rb</em>) requires the very, very basics that Rails needs to get going. I&#8217;m not going to delve into these areas yet, just cover them briefly for now. Later on we will go through the ones that are important to the boot procedure.</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require 'pathname'

  require 'active_support'
  require 'active_support/core_ext/kernel/reporting'
  require 'active_support/core_ext/logger'

  require 'rails/application'
  require 'rails/version'
  require 'rails/deprecation'
  require 'rails/log_subscriber'
  require 'rails/ruby_version_check'

  require 'active_support/railtie'
  require 'action_dispatch/railtie'
</pre>
</div>
</notextile>

<p><tt>require 'pathname'</tt> requires the Pathname class which is used for returning a Pathname object for <tt>Rails.root</tt>. Although is coming to use this path name to generate paths as below:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Rails.root.join(&quot;app/controllers&quot;)
</pre>
</div>
</notextile>

<p>Pathname can also be converted to string, so the following syntax is preferred:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
&quot;#{Rails.root}/app/controllers&quot;
</pre>
</div>
</notextile>

<p>This works because Ruby automatically handles file path conversions. Although this is not new to Rails 3 (it was available in 2.3.5), it is something worthwhile pointing out.</p>
<p>Inside this file there are other helpful helper methods defined, such as <tt>Rails.root</tt>, <tt>Rails.env</tt>, <tt>Rails.logger</tt> and <tt>Rails.application</tt>.</p>
<p>The first require:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require 'active_support'
</pre>
</div>
</notextile>

<p>Is not ran as this was already required by <em>actionpack/lib/action_dispatch.rb</em>.</p>
<h4 id="require-active_support-core_ext-kernel-reporting">5.10 <tt>require 'active_support/core_ext/kernel/reporting'</tt></h4>
<p>This file extends the <tt>Kernel</tt> module, providing the methods <tt>silence_warnings</tt>, <tt>enable_warnings</tt>, <tt>with_warnings</tt>, <tt>silence_stderr</tt>, <tt>silence_stream</tt> and <tt>suppress</tt>. The <span class="caps">API</span> documentation on these overridden methods is fairly good and if you wish to know more <a href="http://api.rubyonrails.org/classes/Kernel.html">have a read.</a></p>
<p>For information on this file see the &#8220;Core Extensions&#8221; guide. <span class="caps">TODO</span>: link to guide.</p>
<h4 id="require-active_support-core_ext-logger">5.11 <tt>require 'active_support/core_ext/logger'</tt></h4>
<p>For information on this file see the &#8220;Core Extensions&#8221; guide. <span class="caps">TODO</span>: link to guide.</p>
<h4 id="require-rails-application">5.12 <tt>require 'rails/application'</tt></h4>
<p>Here&#8217;s where <tt>Rails::Application</tt> is defined. This is the superclass of <tt>YourApp::Application</tt> from <em>config/application.rb</em> and the subclass of <tt>Rails::Engine</tt> This is the main entry-point into the Rails initialization process as when your application is initialized, your class is the basis of its configuration.</p>
<p>This file requires three important files before <tt>Rails::Application</tt> is defined: <em>rails/railties_path.rb</em>, <em>rails/plugin.rb</em> and <em>rails/engine.rb</em>.</p>
<h4 id="require-rails-railties_path">5.13 <tt>require 'rails/railties_path'</tt></h4>
<p>This file serves one purpose:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
RAILTIES_PATH = File.expand_path(File.join(File.dirname(__FILE__), '..', '..'))
</pre>
</div>
</notextile>

<p>Helpful, hey? One must wonder why they just didn&#8217;t define it outright.</p>
<h4 id="require-rails-plugin">5.14 <tt>require 'rails/plugin'</tt></h4>
<p>Firstly this file requires <em>rails/engine.rb</em>, which defines our <tt>Rails::Engine</tt> class, explained in the very next section.</p>
<p>This file defines a class called <tt>Rails::Plugin</tt> which descends from <tt>Rails::Engine</tt>.</p>
<p>This defines the first few initializers for the Rails stack:</p>
<ul>
	<li>load_init_rb</li>
	<li>sanity_check_railties_collisons</li>
</ul>
<p>These are explained in the Initialization section. <span class="caps">TODO</span>: First write initialization section then come back here and link.
<span class="caps">TODO</span>: Expand.</p>
<h4 id="require-rails-engine">5.15 <tt>require 'rails/engine'</tt></h4>
<p>This file requires <em>rails/railtie.rb</em> which defines <tt>Rails::Railtie</tt>.</p>
<p><tt>Rails::Engine</tt> defines a couple of further initializers for your application:</p>
<ul>
	<li>set_load_path</li>
	<li>set_autoload_paths</li>
	<li>add_routing_paths</li>
	<li>add_routing_namespaces</li>
	<li>add_locales</li>
	<li>add_view_paths</li>
	<li>add_generator_templates</li>
	<li>load_application_initializers</li>
	<li>load_application_classes</li>
</ul>
<p>These are explained in the Initialization section. <span class="caps">TODO</span>: First write initialization section then come back here and link.</p>
<p>Also in here we see that a couple of methods are <tt>delegate</tt>&#8217;d:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
delegate :middleware, :paths, :root, :to =&gt; :config
</pre>
</div>
</notextile>

<p>This means when you call either the <tt>middleware</tt>, <tt>paths</tt> or <tt>root</tt> methods you are in reality calling <tt>config.middleware</tt>, <tt>config.paths</tt> and <tt>config.root</tt> respectively.</p>
<p><tt>Rails::Engine</tt> descends from <tt>Rails::Railtie</tt>.</p>
<h4 id="require-rails-railtie">5.16 <tt>require 'rails/railtie'</tt></h4>
<p><tt>Rails::Railtie</tt> (<em>pronounced Rail-tie, as in a bowtie</em>), provides a method of classes to hook into Rails, providing them with methods to add generators, rake tasks and subscribers. All of the facets of Rails are their own Railtie. and as you&#8217;ve probably already figured out, the engines that you use are railties too. Plugins also can be railties, but they do not have to be.</p>
<p>Here there&#8217;s requires to <em>rails/initializable.rb</em> and and <em>rails/configurable.rb</em>.</p>
<h4 id="require-rails-initializable">5.17 <tt>require 'rails/initializable'</tt></h4>
<p>The <tt>Rails::Initializable</tt> module includes methods helpful for the initialization process in rails, such as the method to define initializers: <tt>initializer</tt>. This is included into <tt>Rails::Railtie</tt> so it&#8217;s available there as well as <tt>Rails::Engine</tt>, <tt>Rails::Application</tt> and <tt>YourApp::Application</tt>. In here we also see the class definition for <tt>Rails::Initializer</tt>, the class for all initializer objects.</p>
<h4 id="require-rails-configuration">5.18 <tt>require 'rails/configuration'</tt></h4>
<p>The <tt>Rails::Configuration</tt> module sets up shared configuration for applications, engines and plugins alike.</p>
<p>At the top of this file there are three <tt>require</tt>s:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require 'active_support/ordered_options'
  require 'rails/paths'
  require 'rails/rack'
</pre>
</div>
</notextile>

<h4 id="require-active_support-ordered_options">5.19 <tt>require 'active_support/ordered_options'</tt></h4>
<p><tt>ActiveSupport::OrderedOptions</tt> is a special-purpose <tt>OrderedHash</tt>, used for keeping track of the options specified in the configuration of your application.</p>
<p><span class="caps">TODO</span>: expand.</p>
<h4 id="require-rails-paths">5.20 <tt>require 'rails/paths'</tt></h4>
<p>This file is used to set up the <tt>Rails::Paths</tt> module which is used to set up helpers for referencing paths to the folders of your Rails application, such as in <em>railties/lib/rails/engine/configuration.rb</em> where it is used to firstly define them:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def paths
    @paths ||= begin
      paths = Rails::Paths::Root.new(@root)
      paths.app                 &quot;app&quot;,                 :eager_load =&gt; true, :glob =&gt; &quot;*&quot;
      paths.app.controllers     &quot;app/controllers&quot;,     :eager_load =&gt; true
      paths.app.helpers         &quot;app/helpers&quot;,         :eager_load =&gt; true
      paths.app.models          &quot;app/models&quot;,          :eager_load =&gt; true
      paths.app.mailers         &quot;app/mailers&quot;,         :eager_load =&gt; true
      paths.app.views           &quot;app/views&quot;,           :eager_load =&gt; true
      paths.lib                 &quot;lib&quot;,                 :load_path =&gt; true
      paths.lib.tasks           &quot;lib/tasks&quot;,           :glob =&gt; &quot;**/*.rake&quot;
      paths.lib.templates       &quot;lib/templates&quot;
      paths.config              &quot;config&quot;
      paths.config.initializers &quot;config/initializers&quot;, :glob =&gt; &quot;**/*.rb&quot;
      paths.config.locales      &quot;config/locales&quot;,      :glob =&gt; &quot;*.{rb,yml}&quot;
      paths.config.routes       &quot;config/routes.rb&quot;
      paths.public              &quot;public&quot;
      paths.public.javascripts  &quot;public/javascripts&quot;
      paths.public.stylesheets  &quot;public/stylesheets&quot;
      paths
    end
  end
</pre>
</div>
</notextile>

<p>You can then get to these helper methods by calling <tt>YourApp::Application.config.paths</tt>.</p>
<h4 id="require-rails-rack">5.21 <tt>require 'rails/rack'</tt></h4>
<p>This file sets up some <tt>autoload</tt>&#8217;d constants for <tt>Rails::Rack</tt>:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
module Rails
    module Rack
      autoload :Debugger,  &quot;rails/rack/debugger&quot;
      autoload :Logger,    &quot;rails/rack/logger&quot;
      autoload :LogTailer, &quot;rails/rack/log_tailer&quot;
      autoload :Static,    &quot;rails/rack/static&quot;
    end
  end
</pre>
</div>
</notextile>

<h4 id="require-rails-version">5.22 <tt>require 'rails/version'</tt></h4>
<p>Now we&#8217;re back to <em>rails.rb</em>. The line after <tt>require 'rails/application'</tt> in <em>rails.rb</em> is:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require 'rails/version'
</pre>
</div>
</notextile>

<p>The code in this file declares <tt>Rails::VERSION</tt> so that the version number can easily be accessed. It stores it in constants, with the final version number being attainable by calling <tt>Rails::VERSION::STRING</tt>.</p>
<h4 id="require-rails-deprecation">5.23 <tt>require 'rails/deprecation'</tt></h4>
<p>This sets up a couple of familiar constants: <tt>RAILS_ENV</tt>, <tt>RAILS_ROOT</tt> and <tt>RAILS_DEFAULT_LOGGER</tt> to still be usable, but raise a deprecation warning when they are. Their alternatives are now <tt>Rails.env</tt>, <tt>Rails.root</tt> and <tt>Rails.logger</tt> respectively.</p>
<p>If you wish to know more about how they&#8217;re deprecated see the <tt>require 'active_support/deprecation/proxy_wrappers'</tt> section. <span class="caps">TODO</span>: link to section.</p>
<h4 id="require-rails-log_subscriber">5.24 <tt>require 'rails/log_subscriber'</tt></h4>
<p>The <tt>Rails::LogSubscriber</tt> provides a central location for logging in Rails 3 so as to not slow down the main thread. When you call one of the logging methods (<tt>info</tt>, <tt>debug</tt>, <tt>warn</tt>, <tt>error</tt>, <tt>fatal</tt> or <tt>unknown</tt>) from the <tt>Rails::LogSubscriber</tt> class or one of its subclasses this will notify the Rails logger to log this call in the fashion you specify, but will not write it to the file. The file writing is done at the end of the request, courtesy of the <tt>Rails::Rack::Logger</tt> middleware.</p>
<p>Each Railtie defines its own class that descends from <tt>Rails::LogSubscriber</tt> with each defining its own methods for logging individual tasks.</p>
<h4 id="require-rails-ruby_version_check">5.25 <tt>require 'rails/ruby_version_check'</tt></h4>
<p>This file ensures that you&#8217;re running a minimum of 1.8.7. If you&#8217;re running an older version, it will tell you:</p>
<pre>
  Rails requires Ruby version 1.8.7 or later.
  You're running [your Ruby version here]; please upgrade to continue.
</pre>
<h4 id="require-activesupport-railtie">5.26 <tt>require 'activesupport/railtie'</tt></h4>
<p>This file declares two Railties, one for ActiveSupport and the other for I18n. In these Railties there&#8217;s the following initializers defined:</p>
<ul>
	<li>active_support.initialize_whiny_nils</li>
	<li>active_support.initialize_time_zone</li>
</ul>
<ul>
	<li>i18n.initialize</li>
</ul>
<p>This Railtie also defines an an <tt>after_initialize</tt> block, which will (as the name implies) be ran after the initialization process. More on this later. <span class="caps">TODO</span>: When you write the section you can link to it.</p>
<h4 id="require-action_dispatch-railtie">5.27 <tt>require 'action_dispatch/railtie'</tt></h4>
<p>This file is explained in the ActionDispatch Railtie Section. <span class="caps">TODO</span>: link</p>
<h4 id="return-to-_rails-all-rb_">5.28 Return to <em>rails/all.rb</em></h4>
<p>Now that we&#8217;ve covered the extensive process of what the first line does in this file, lets cover the remainder:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
%w(
    active_record
    action_controller
    action_mailer
    active_resource
    rails/test_unit
  ).each do |framework|
    begin
      require &quot;#{framework}/railtie&quot;
    rescue LoadError
    end
  end
</pre>
</div>
</notextile>

<p>As you may be able to tell from the code, this is going through and loading all the Railties for Active Record, Action Controller, Action Mailer, Active Resource. Two other Railties, one for Active Support and one for Action Dispatch were required earlier, but are still covered in this section for continuity reasons. <span class="caps">TODO</span>: link.</p>
<h4 id="activesupport-railtie">5.29 ActiveSupport Railtie</h4>
<p>From Active Support&#8217;s <span class="caps">README</span>:</p>
<p>Active Support is a collection of various utility classes and standard library extensions that were found useful for Rails.</p>
<p><span class="caps">TODO</span>: Quotify.</p>
<h5 id="require-active_support-railtie">5.29.1 <tt>require 'active_support/railtie'</tt></h5>
<h4 id="active-record-railtie">5.30 Active Record Railtie</h4>
<p>The Active Record Railtie takes care of hooking Active Record into Rails. This depends on Active Support, Active Model and Arel. From Active Record&#8217;s readme:</p>
<p><span class="caps">TODO</span>: Quotify.</p>
<notextile>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
Active Record connects business objects and database tables to create a persistable domain model where logic and data are presented in one wrapping. It's an implementation of the object-relational mapping (ORM) pattern by the same name as described by Martin Fowler:

    &quot;An object that wraps a row in a database table or view, encapsulates
         the database access, and adds domain logic on that data.&quot;

  Active Record's main contribution to the pattern is to relieve the original of two stunting problems:
  lack of associations and inheritance. By adding a simple domain language-like set of macros to describe
  the former and integrating the Single Table Inheritance pattern for the latter, Active Record narrows the
  gap of functionality between the data mapper and active record approach.
</pre>
</div>
</notextile>

<h5 id="require-active_record-railtie">5.30.1 <tt>require "active_record/railtie"</tt></h5>
<p>The <em>activerecord/lib/active_record/railtie.rb</em> file defines the Railtie for Active Record.</p>
<p>This file first requires Active Record, the <em>railties/lib/rails.rb</em> file which has already been required and so will be ignored, and the Active Model Railtie:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require &quot;active_record&quot;
  require &quot;rails&quot;
  require &quot;active_model/railtie&quot;
</pre>
</div>
</notextile>

<p>Active Model&#8217;s Railtie is covered in the next section. <span class="caps">TODO</span>: Section.</p>
<h5 id="require-active_record">5.30.2 <tt>require "active_record"</tt></h5>
<p><span class="caps">TODO</span>: Why are <tt>activesupport_path</tt> and <tt>activemodel_path</tt> defined here?</p>
<p>The first three requires require ActiveSupport, Active Model and ARel in that order:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require 'active_support'
  require 'active_model'
  require 'arel'
</pre>
</div>
</notextile>

<h5 id="require-active_support">5.30.3 <tt>require "active_support"</tt></h5>
<p>This was loaded earlier by <em>railties/lib/rails.rb</em>. This line is here as a safeguard for when Active Record is loaded outside the scope of Rails.</p>
<h5 id="require-active_model">5.30.4 <tt>require "active_model"</tt></h5>
<p><span class="caps">TODO</span>: Again with the <tt>activesupport_path</tt>!</p>
<p>Here we see another <tt>require "active_support"</tt> this is again, a safeguard for when Active Model is loaded outside the scope of Rails.</p>
<p>This file defines a few <tt>autoload</tt>&#8217;d modules for Active Model, requires <tt>active_support/i18n</tt> and adds the default translation file for Active Model to <tt>I18n.load_path</tt>.</p>
<p>The <tt>require 'active_support/i18n'</tt> just loads I18n and adds Active Support&#8217;s default translations file to <tt>I18n.load_path</tt> too:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require 'i18n'
  I18n.load_path &lt;&lt; &quot;#{File.dirname(__FILE__)}/locale/en.yml
</pre>
</div>
</notextile>

<h5 id="require-arel">5.30.5 <tt>require "arel"</tt></h5>
<p>This file in <em>arel/lib/arel.rb</em> loads a couple of Active Support things first:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require 'active_support/inflector'
  require 'active_support/core_ext/module/delegation'
  require 'active_support/core_ext/class/attribute_accessors'
</pre>
</div>
</notextile>

<p>These files are explained in the &#8220;Common Includes&#8221; section.</p>
<h5 id="require-arel">5.30.6 <tt>require 'arel'</tt></h5>
<p>Back in <em>arel/lib/arel.rb</em>, the next two lines require Active Record parts:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require 'active_record'
  require 'active_record/connection_adapters/abstract/quoting'
</pre>
</div>
</notextile>

<p>Because we&#8217;re currently loading <em>active_record.rb</em>, it skips right over it.</p>
<h5 id="require-active_record-connection_adapters-abstract-quoting">5.30.7 <tt>require 'active_record/connection_adapters/abstract/quoting'</tt></h5>
<p><em>activerecord/lib/active_record/connection_adapters/abstract/quoting.rb</em> defines methods used for quoting fields and table names in Active Record.</p>
<p><span class="caps">TODO</span>: Explain why this is loaded especially.</p>
<h5 id="require-active_record">5.30.8 <tt>require 'active_record'</tt></h5>
<p>Back the initial require from the <em>railtie.rb</em>.</p>
<p>The <em>active_support</em> and <em>active_model</em> requires are again just an insurance for if we&#8217;re loading Active Record outside of the scope of Rails. In <em>active_record.rb</em> the ActiveRecord <tt>Module</tt> is initialized and in it there is defined a couple of <tt>autoloads</tt> and <tt>eager_autoloads</tt>.</p>
<p>There&#8217;s a new method here called <tt>autoload_under</tt> which is defined in <tt>ActiveSupport::Autoload</tt>. This sets the autoload path to temporarily be the specified path, in this case <tt>relation</tt> for the <tt>autoload</tt>&#8217;d classes inside the block.</p>
<p>Inside this file the <tt>AttributeMethods</tt>, <tt>Locking</tt> and <tt>ConnectionAdapter</tt> modules are defined inside the <tt>ActiveRecord</tt> module. The second to last line tells Arel what <span class="caps">SQL</span> engine we want to use. In this case it&#8217;s <tt>ActiveRecord::Base</tt>. The final line adds in the translations for Active Record which are only for if a record is invalid or non-unique.</p>
<h5 id="require-rails">5.30.9 <tt>require 'rails'</tt></h5>
<p>As mentioned previously this is skipped over as it has been already loaded. If you&#8217;d still like to see what this file does go to section <span class="caps">TODO</span>: section.</p>
<h5 id="require-active_model-railtie">5.30.10 <tt>require 'active_model/railtie'</tt></h5>
<p>This is covered in the Active Model Railtie section. <span class="caps">TODO</span>: link there.</p>
<h5 id="require-action_controller-railtie">5.30.11 <tt>require 'action_controller/railtie'</tt></h5>
<p>This is covered in the Action Controller Railtie section. <span class="caps">TODO</span>: link there.</p>
<h5 id="the-active-record-railtie">5.30.12 The Active Record Railtie</h5>
<p>Inside the Active Record Railtie the <tt>ActiveRecord::Railtie</tt> class is defined:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
module ActiveRecord
    class Railtie &lt; Rails::Railtie

    ...
    end
  end
</pre>
</div>
</notextile>

<p><span class="caps">TODO</span>: Explain the logger.</p>
<p>By doing this the <tt>ActiveRecord::Railtie</tt> class gains access to the methods contained within <tt>Rails::Railtie</tt> such as <tt>rake_tasks</tt>, <tt>log_subscriber</tt> and <tt>initiailizer</tt>, all of which the Railtie is using in this case. The initializers defined here are:</p>
<ul>
	<li>active_record.initialize_timezone</li>
	<li>active_record.logger</li>
	<li>active_record.set_configs</li>
	<li>active_record.initialize_database</li>
	<li>active_record.log_runtime</li>
	<li>active_record.initialize_database_middleware</li>
	<li>active_record.load_observers</li>
	<li>active_record.set_dispatch_hooks</li>
</ul>
<p>As with the engine initializers, these are explained later.</p>
<h4 id="active-model-railtie">5.31 Active Model Railtie</h4>
<p>This Railtie is <tt>require</tt>&#8216;d by Active Record&#8217;s Railtie.</p>
<p>From the Active Model readme:</p>
<notextile>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
Prior to Rails 3.0, if a plugin or gem developer wanted to be able to have an object interact with Action Pack helpers, it was required to either copy chunks of code from Rails, or monkey patch entire helpers to make them handle objects that did not look like Active Record.  This generated code duplication and fragile applications that broke on upgrades.

  Active Model is a solution for this problem.

  Active Model provides a known set of interfaces that your objects can implement to then present a common interface to the Action Pack helpers.
</pre>
</div>
</notextile>

<h5 id="require-active_model-railtie">5.31.1 <tt>require "active_model/railtie"</tt></h5>
<p>This Railtie file, <em>activemodel/lib/active_model/railtie.rb</em> is quite small and only requires in <tt>active_model</tt>. As mentioned previously, the require to <em>rails</em> is skipped over as it has been already loaded. If you&#8217;d still like to see what this file does go to section <span class="caps">TODO</span>: section.</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require &quot;active_model&quot;
  require &quot;rails&quot;
</pre>
</div>
</notextile>

<h5 id="require-active_model">5.31.2 <tt>require "active_model"</tt></h5>
<p>Active Model depends on Active Support and ensures it is required by making a <tt>require 'active_support'</tt> call. It has already been loaded from <em>railties/lib/rails.rb</em> so will not be reloaded for us here. The file goes on to define the <tt>ActiveModel</tt> module and all of its autoloaded classes. This file also defines the english translations for some of the validation messages provided by Active Model, such as &#8220;is not included in the list&#8221; and &#8220;is reserved&#8221;.</p>
<h4 id="action-controller-railtie">5.32 Action Controller Railtie</h4>
<p>The Action Controller Railtie takes care of all the behind-the-scenes code for your controllers; it puts the C into <span class="caps">MVC</span>; and does so by implementing the <tt>ActionController::Base</tt> class which you may recall is where your <tt>ApplicationController</tt> class descends from.</p>
<h5 id="require-action_controller-railtie">5.32.1 <tt>require 'action_controller/railtie'</tt></h5>
<p>This first makes a couple of requires:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require &quot;action_controller&quot;
  require &quot;rails&quot;
  require &quot;action_view/railtie&quot;
</pre>
</div>
</notextile>

<p>The <em>action_controller</em> file is explained in the very next section. The require to <em>rails</em> is requiring the already-required <em>railties/lib/rails.rb</em>. If you wish to know about the require to <em>action_view/railtie</em> this is explained in the Action View Railtie section.</p>
<h5 id="require-action_controller">5.32.2 <tt>require 'action_controller</tt></h5>
<p>This file, <em>actionpack/lib/action_controller.rb</em>, defines the Action Controller module and its relative autoloads. Before it does any of that it makes two requires: one to <em>abstract_controller</em>, explored next, and the other to <em>action_dispatch</em>, explored directly after that.</p>
<h5 id="require-abstract_controller">5.32.3 <tt>require 'abstract_controller'</tt></h5>
<p><tt>AbstractController</tt> provides the functionality of <span class="caps">TODO</span>.</p>
<p>This file is in <em>actionpack/lib/abstract_controller.rb</em> and begins by attempting to add the path to Active Support to the load path, which it would succeed in if it wasn&#8217;t already set by anything loaded before it. In this case, it&#8217;s not going to be set due to Arel already loading it in (<span class="caps">TODO</span>: right?).</p>
<p>The next thing in this file four <tt>require</tt> calls:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require 'active_support/ruby/shim'
  require 'active_support/dependencies/autoload'
  require 'active_support/core_ext/module/attr_internal'
  require 'active_support/core_ext/module/delegation'
</pre>
</div>
</notextile>

<p>After these require calls the <tt>AbstractController</tt> module is defined with some standard <tt>autoload</tt>&#8217;d classes.</p>
<h5 id="require-active_support-ruby-shim">5.32.4 <tt>require 'active_support/ruby/shim'</tt></h5>
<p>This file is explained in the &#8220;Common Includes&#8221; section beneath.</p>
<h5 id="require-active_support-dependencies-autoload">5.32.5 <tt>require 'active_support/dependencies/autoload</tt></h5>
<p>This file was loaded upon the first require of <tt>active_support</tt> and is not included. If you wish to be refreshed on what this file performs visit <span class="caps">TODO</span>: link to section.</p>
<h5 id="require-active_support-core_ext-module-attr_internal">5.32.6 <tt>require 'active_support/core_ext/module/attr_internal'</tt></h5>
<p>This file is explained in the &#8220;Common Includes&#8221; section as it is required again later on. See the <span class="caps">TODO</span>: section. I also think this may be explained in the Active Support Core Extensions guide.</p>
<h5 id="require-active_support-core_ext-module-delegation">5.32.7 <tt>require 'active_support/core_ext/module/delegation'</tt></h5>
<p>This file is explained in the &#8220;Common Includes&#8221; section as it has already been required by Arel at this point in the initialization process (see: section <span class="caps">TODO</span>: <span class="caps">LINK</span>!).</p>
<h5 id="require-action_controller">5.32.8 <tt>require 'action_controller'</tt></h5>
<p>Back to <em>actionpack/lib/action_controller.rb</em>.</p>
<p>After the initial call to <tt>require 'abstract_controller'</tt>, this calls <tt>require 'action_dispatch'</tt> which was required earlier by <em>railties/lib/rails.rb</em>. The purpose of this file is explained in the ActionDispatch Railtie section.</p>
<p>This file defines the <tt>ActionController</tt> module and its autoloaded classes.</p>
<p>Here we have a new method called <tt>autoload_under</tt>. This was covered in the Active Record Railtie but it is covered here also just in case you missed or skimmed over it. The <tt>autoload_under</tt> method is  defined in <tt>ActiveSupport::Autoload</tt> and it sets the autoload path to temporarily be the specified path, in this case by specifying <em>metal</em> it will load the specified <tt>autoload</tt>&#8217;d classes from <em>lib/action_controller/metal</em> inside the block.</p>
<p>Another new method we have here is called <tt>autoload_at</tt>:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
autoload_at &quot;action_controller/metal/exceptions&quot; do
    autoload :ActionControllerError
    autoload :RenderError
    autoload :RoutingError
    autoload :MethodNotAllowed
    autoload :NotImplemented
    autoload :UnknownController
    autoload :MissingFile
    autoload :RenderError
    autoload :SessionOverflowError
    autoload :UnknownHttpMethod
  end
</pre>
</div>
</notextile>

<p>This defines the path of which to find these classes defined at and is most useful for if you have multiple classes defined in a single file, as is the case for this block; all of those classes are defined inside <em>action_controller/metal/exceptions.rb</em> and when Active Support goes looking for them it will look in that file.</p>
<p>At the end of this file there are a couple more requires:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
# All of these simply register additional autoloads
  require 'action_view'
  require 'action_controller/vendor/html-scanner'

  # Common Active Support usage in ActionController
  require 'active_support/concern'
  require 'active_support/core_ext/class/attribute_accessors'
  require 'active_support/core_ext/load_error'
  require 'active_support/core_ext/module/attr_internal'
  require 'active_support/core_ext/module/delegation'
  require 'active_support/core_ext/name_error'
  require 'active_support/inflector'
</pre>
</div>
</notextile>

<h5 id="require-action_view">5.32.9 <tt>require 'action_view'</tt></h5>
<p>This is best covered in the Action View Railtie section, so skip there by <span class="caps">TODO</span>: Link / page?</p>
<h5 id="require-action_controller-vendor-html-scanner">5.32.10 <tt>require 'action_controller/vendor/html-scanner'</tt></h5>
<p><span class="caps">TODO</span>: What is the purpose of this? Find out.</p>
<h5 id="require-active_support-concern">5.32.11 <tt>require 'active_support/concern'</tt></h5>
<p><span class="caps">TODO</span>: I can kind of understand the purpose of this.. need to see where @_dependencies is used however.</p>
<h5 id="require-active_support-core_ext-class-attribute_accessors">5.32.12 <tt>require 'active_support/core_ext/class/attribute_accessors'</tt></h5>
<p>This file defines, as the path implies, attribute accessors for class. These are <tt>cattr_reader</tt>, <tt>cattr_writer</tt>, <tt>cattr_accessor</tt>.</p>
<h5 id="require-active_support-core_ext-load_error">5.32.13 <tt>require 'active_support/core_ext/load_error'</tt></h5>
<p>The Active Support Core Extensions (<span class="caps">TODO</span>: <span class="caps">LINK</span>!) guide has a great coverage of what this file precisely provides.</p>
<h5 id="require-active_support-core_ext-module-attr_internal">5.32.14 <tt>require 'active_support/core_ext/module/attr_internal'</tt></h5>
<p>This file is explained in the &#8220;Core Extension&#8221; guide.</p>
<p>This file was required through the earlier <em>abstract_controller.rb</em> require.</p>
<h5 id="require-active_support-core_ext-module-delegation">5.32.15 <tt>require 'active_support/core_ext/module/delegation'</tt></h5>
<p>This file is explained in the &#8220;Common Includes&#8221; section.</p>
<p>This file was required earlier by Arel and so is not required again.</p>
<h5 id="require-active_support-core_ext-name_error">5.32.16 <tt>require 'active_support/core_ext/name_error'</tt></h5>
<p>This file includes extensions to the <tt>NameError</tt> class, providing the <tt>missing_name</tt> and <tt>missing_name?</tt> methods. For more information see the Active Support Core Extensions guide.</p>
<h5 id="require-active_support-inflector">5.32.17 <tt>require 'active_support/inflector'</tt></h5>
<p>This file is explained in the &#8220;Common Includes&#8221; section.</p>
<p>This file was earlier required by Arel and so is not required again.</p>
<h5 id="action-controller-railtie">5.32.18 Action Controller Railtie</h5>
<p>So now we come back to the Action Controller Railtie with a couple more requires to go before <tt>ActionController::Railtie</tt> is defined:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require &quot;action_view/railtie&quot;
  require &quot;active_support/core_ext/class/subclasses&quot;
  require &quot;active_support/deprecation/proxy_wrappers&quot;
  require &quot;active_support/deprecation&quot;
</pre>
</div>
</notextile>

<p>As explained previously the <tt>action_view/railtie</tt> file will be explained in the Action View Railtie section. <span class="caps">TODO</span>: link to it.</p>
<h5 id="require-active_support-core_ext-class-subclasses">5.32.19 <tt>require 'active_support/core_ext/class/subclasses'</tt></h5>
<p>For an explanation of this file <em>activesupport/lib/active_support/core_ext/class/subclasses</em>, see the Active Support Core Extension guide.</p>
<h5 id="require-active_support-deprecation-proxy_wrappers">5.32.20 <tt>require 'active_support/deprecation/proxy_wrappers'</tt></h5>
<p>This file, <em>activesupport/lib/active_support/deprecation/proxy_wrappers.rb</em>, defines a couple of deprecation classes, which are <tt>DeprecationProxy</tt>, <tt>DeprecationObjectProxy</tt>, <tt>DeprecationInstanceVariableProxy</tt>, <tt>DeprecationConstantProxy</tt> which are all namespaced into <tt>ActiveSupport::Deprecation</tt>. These last three are all subclasses of <tt>DeprecationProxy</tt>.</p>
<p>Why do we mention them here? Beside the obvious-by-now fact that we&#8217;re covering just about everything about the initialization process in this guide, if you&#8217;re deprecating something in your library and you use Active Support, you too can use the <tt>DeprecationProxy</tt> class (and it&#8217;s subclasses) too.</p>
<h6 id="deprecationproxy">5.32.20.1 <tt>DeprecationProxy</tt></h6>
<p>This class is used only in <em>railties/lib/rails/deprecation.rb</em>, loaded further on in the initialization process. It&#8217;s used in this way:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
RAILS_ROOT = (Class.new(ActiveSupport::Deprecation::DeprecationProxy) do
    cattr_accessor :warned
    self.warned = false

    def target
      Rails.root
    end

    def replace(*args)
      warn(caller, :replace, *args)
    end

    def warn(callstack, called, args)
      unless warned
        ActiveSupport::Deprecation.warn(&quot;RAILS_ROOT is deprecated! Use Rails.root instead&quot;, callstack)
        self.warned = true
      end
    end
  end).new
</pre>
</div>
</notextile>

<p>There is similar definitions for the other constants of <tt>RAILS_ENV</tt> and <tt>RAILS_DEFAULT_LOGGER</tt>. All three of these constants are in the midst of being deprecated (most likely in Rails 3.1) so Rails will tell you if you reference them that they&#8217;re deprecated using the <tt>DeprecationProxy</tt> class. Whenever you call <tt>RAILS_ROOT</tt> this will raise a warning, telling you: &#8220;RAILS_ROOT is deprecated! Use Rails.root instead&#8221;&#8230;. <span class="caps">TODO</span>: investigate if simply calling it does raise this warning. This same rule applies to <tt>RAILS_ENV</tt> and <tt>RAILS_DEFAULT_LOGGER</tt>, their new alternatives are <tt>Rails.env</tt> and <tt>Rails.logger</tt> respectively.</p>
<h6 id="deprecatedobjectproxy">5.32.20.2 <tt>DeprecatedObjectProxy</tt></h6>
<p>This is used in one place <em>actionpack/lib/action_controller/railtie.rb</em>, which you may remember is how we got to the <tt>DeprecationProxy</tt> section:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
ActiveSupport::Deprecation::DeprecatedObjectProxy.new(app.routes, message)
</pre>
</div>
</notextile>

<p>This makes more sense in the wider scope of the initializer:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
initializer &quot;action_controller.url_helpers&quot; do |app|
    ActionController.base_hook do
      extend ::ActionController::Railtie::UrlHelpers.with(app.routes)
    end

    message = &quot;ActionController::Routing::Routes is deprecated. &quot; \
              &quot;Instead, use Rails.application.routes&quot;

    proxy = ActiveSupport::Deprecation::DeprecatedObjectProxy.new(app.routes, message)
    ActionController::Routing::Routes = proxy
  end
</pre>
</div>
</notextile>

<p><tt>ActionController::Routing::Routes</tt> was the previous constant used in defining routes in Rails 2 applications, now it&#8217;s simply a method on <tt>Rails.application</tt> rather than it&#8217;s own individual class: <tt>Rails.application.routes</tt>. Both of these still call the <tt>draw</tt> method on the returned object to end up defining the routes.</p>
<h6 id="deprecatedinstancevariableproxy">5.32.20.3 <tt>DeprecatedInstanceVariableProxy</tt></h6>
<p>This isn&#8217;t actually used anywhere in Rails anymore. It was used previously for when <tt>@request</tt> and <tt>@params</tt> were deprecated in Rails 2. It has been kept around as it could be useful for the same purposes in libraries that use Active Support.</p>
<h6 id="deprecatedconstantproxy">5.32.20.4 <tt>DeprecatedConstantProxy</tt></h6>
<p>This method is used in a couple of places, <em>activesupport/lib/active_support/json/encoding.rb</em> and <em>railties/lib/rails/rack.rb</em>.</p>
<p>In <em>encoding.rb</em> it&#8217;s used to define a constant that&#8217;s now been deprecated:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
CircularReferenceError = Deprecation::DeprecatedConstantProxy.new('ActiveSupport::JSON::CircularReferenceError', Encoding::CircularReferenceError)
</pre>
</div>
</notextile>

<p>Now when you reference <tt>ActiveSupport::JSON::CircularReferenceError</tt> you&#8217;ll receive a warning:</p>
<notextile>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
ActiveSupport::JSON::CircularReferenceError is deprecated! Use Encoding::CircularReferenceError instead.
</pre>
</div>
</notextile>

<h5 id="require-active_support-deprecation">5.32.21 <tt>require "active_support/deprecation"</tt></h5>
<p>This re-opens the <tt>ActiveSupport::Deprecation</tt> module which was already defined by our deprecation proxies. Before this happens however we have 4 requires:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require 'active_support/deprecation/behaviors'
  require 'active_support/deprecation/reporting'
  require 'active_support/deprecation/method_wrappers'
  require 'active_support/deprecation/proxy_wrappers'
</pre>
</div>
</notextile>

<p>The remainder of this file goes about setting up the <tt>silenced</tt> and <tt>debug</tt> accessors:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
module ActiveSupport
    module Deprecation #:nodoc:
      class &lt;&lt; self
        # The version the deprecated behavior will be removed, by default.
        attr_accessor :deprecation_horizon
      end
      self.deprecation_horizon = '3.0'

      # By default, warnings are not silenced and debugging is off.
      self.silenced = false
      self.debug = false
    end
  end
</pre>
</div>
</notextile>

<h5 id="require-active_support-deprecation-behaviors">5.32.22 <tt>require "active_support/deprecation/behaviors"</tt></h5>
<p>This sets up some default behavior for the warnings raised by <tt>ActiveSupport::Deprecation</tt>, defining different ones for <em>development</em> and <em>test</em> and nothing for production, as we never want deprecation warnings in production:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
# Default warning behaviors per Rails.env. Ignored in production.
  DEFAULT_BEHAVIORS = {
    'test' =&gt; Proc.new { |message, callstack|
       $stderr.puts(message)
       $stderr.puts callstack.join(&quot;\n  &quot;) if debug
     },
    'development' =&gt; Proc.new { |message, callstack|
       logger =
         if defined?(Rails) &amp;&amp; Rails.logger
           Rails.logger
         else
           require 'logger'
           Logger.new($stderr)
         end
       logger.warn message
       logger.debug callstack.join(&quot;\n  &quot;) if debug
     }
  }
</pre>
</div>
</notextile>

<p>In the <em>test</em> environment, we will see the deprecation errors displayed in <tt>$stderr</tt> and in <em>development</em> mode, these are sent to <tt>Rails.logger</tt> if it exists, otherwise it is output to <tt>$stderr</tt> in a very similar fashion to the <em>test</em> environment. These are both defined as procs, so Active Support can pass arguments to the <tt>call</tt> method we call on it when Active Support <tt>warn</tt>.</p>
<h5 id="require-active_support-deprecation-reporting">5.32.23 <tt>require 'active_support/deprecation/reporting'</tt></h5>
<p>This file defines further extensions to the <tt>ActiveSupport::Deprecation</tt> module, including the <tt>warn</tt> method which is used from Active Support&#8217;s <tt>DeprecationProxy</tt> class and an <tt>attr_accessor</tt> on the class called <tt>silenced</tt>. This checks that we have a behavior defined, which we do in the <em>test</em> and <em>development</em> environments, and that we&#8217;re not <tt>silenced</tt> before warning about deprecations by <tt>call</tt>&#8217;ing the <tt>Proc</tt> time.</p>
<p>This file also defines a <tt>silence</tt> method on the module also which you can pass a block to temporarily silence errors:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
ActiveSupport::Deprecation.silence do
    puts &quot;YOU CAN FIND ME HERE: #{RAILS_ROOT}&quot;
  end
</pre>
</div>
</notextile>

<p><span class="caps">TODO</span>: may have to correct this example.</p>
<h5 id="require-active_support-deprecation-method_wrappers">5.32.24 <tt>require 'active_support/deprecation/method_wrappers'</tt></h5>
<p>This file defines a class method on <tt>ActiveSupport::Deprecation</tt> called <tt>deprecate_methods</tt>. This method is used in <em>activesupport/lib/active_support/core_ext/module/deprecation.rb</em> to allow you to declare deprecated methods on modules:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Module
    # Declare that a method has been deprecated.
    #   deprecate :foo
    #   deprecate :bar =&gt; 'message'
    #   deprecate :foo, :bar, :baz =&gt; 'warning!', :qux =&gt; 'gone!'
    def deprecate(*method_names)
      ActiveSupport::Deprecation.deprecate_methods(self, *method_names)
    end
  end
</pre>
</div>
</notextile>

<h5 id="require-action_controller-railtie">5.32.25 <tt>require 'action_controller/railtie'</tt></h5>
<p>Inside <tt>ActionController::Railtie</tt> there are another two requires:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require &quot;action_controller/railties/log_subscriber&quot;
  require &quot;action_controller/railties/url_helpers&quot;
</pre>
</div>
</notextile>

<h5 id="require-action_controller-railties-log_subscriber">5.32.26 <tt>require 'action_controller/railties/log_subscriber'</tt></h5>
<p><tt>ActionController::Railties::LogSubscriber</tt> inherits from <tt>Rails::LogSubscriber</tt> and defines methods for logging such things as action processing and file sending.</p>
<h5 id="require-action_controller-railties-url_helpers">5.32.27 <tt>require 'action_controller/railties/url_helpers'</tt></h5>
<p>This file defines a <tt>with</tt> method on <tt>ActionController::Railtie::UrlHelpers</tt> which is later used in the <tt>action_controller.url_helpers</tt> initializer. For more information see the <tt>action_controller.url_helpers</tt> initializer section.</p>
<h5 id="action-controller-railtie">5.32.28 Action Controller Railtie</h5>
<p>After these requires it deprecates a couple of ex-Action Controller methods and points whomever references them to their ActionDispatch equivalents. These methods are <tt>session</tt>, <tt>session=</tt>, <tt>session_store</tt> and <tt>session_store=</tt>.</p>
<p>After the deprecations, Rails defines the <tt>log_subscriber</tt> to be a new instance of <tt>ActionController::Railties::LogSubscriber</tt> and then go about defining the following initializers, keeping in mind that these are added to the list of initializers defined before hand:</p>
<ul>
	<li>action_controller.logger</li>
	<li>action_controller.set_configs</li>
	<li>action_controller.initialize_framework_caches</li>
	<li>action_controller.set_helpers_path</li>
	<li>action_controller.url_helpers</li>
</ul>
<h4 id="action-view-railtie">5.33 Action View Railtie</h4>
<p>The Action View Railtie provides the backend code for your views and it puts the C into <span class="caps">MVC</span>. This implements the <tt>ActionView::Base</tt> of which all views and partials are objects of.</p>
<h5 id="require-action_view-railtie">5.33.1 <tt>require 'action_view/railtie'</tt></h5>
<p>The Railtie is defined in a file called <em>actionpack/lib/action_view/railtie.rb</em> and initially makes a call to <tt>require 'action_view'</tt>.</p>
<h5 id="require-action_view">5.33.2 <tt>require 'action_view'</tt></h5>
<p>Here again we have the addition of the path to Active Support to the load path attempted, but because it&#8217;s already in the load path it will not be added. Similarly, we have two requires:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require 'active_support/ruby/shim'
  require 'active_support/core_ext/class/attribute_accessors'
</pre>
</div>
</notextile>

<p>And these have already been required. If you wish to know what these files do go to the explanation of each in the &#8220;Common Includes&#8221; section. <span class="caps">TODO</span>: link to them!</p>
<p>This file goes on to <tt>require 'action_pack'</tt> which consists of all this code (comments stripped):</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require 'action_pack/version'
</pre>
</div>
</notextile>

<p>the <em>version</em> file contains this code (comments stripped):</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
module ActionPack #:nodoc:
    module VERSION #:nodoc:
      MAJOR = 3
      MINOR = 0
      TINY  = 0

      STRING = [MAJOR, MINOR, TINY].join('.')
    end
  end
</pre>
</div>
</notextile>

<p><span class="caps">TODO</span>: Why?!</p>
<p>This file goes on to define the <tt>ActionView</tt> module and its <tt>autoload</tt>&#8217;d modules and then goes on to make two more requires:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require 'active_support/core_ext/string/output_safety'
  require 'action_view/base'
</pre>
</div>
</notextile>

<h5 id="require-active_support-core_ext-string-output_safety">5.33.3 <tt>require 'active_support/core_ext/string/output_safety'</tt></h5>
<p>The <em>actionpack/lib/active_support/core_ext/string/output_saftey.rb</em> file is responsible for the code used in escaping <span class="caps">HTML</span> and <span class="caps">JSON</span>, namely the <tt>html_escape</tt> and <tt>json_escape</tt> methods. It does this by overriding these methods in <tt>Erb::Util</tt> which is later included into <tt>ActionView::Base</tt>. This also defines <tt>ActiveSupport::SafeBuffer</tt> which descends from <tt>String</tt> and is used for concatenating safe output from your views to <span class="caps">ERB</span> templates.</p>
<h5 id="require-action_view-base">5.33.4 <tt>require 'action_view/base'</tt></h5>
<p>This file initially makes requires to the following files:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require 'active_support/core_ext/module/attr_internal'
  require 'active_support/core_ext/module/delegation'
  require 'active_support/core_ext/class/attribute'
</pre>
</div>
</notextile>

<p>These are explained in their relevant areas inside the &#8220;Common Includes&#8221; section.</p>
<p>The remainder of this file sets up the <tt>ActionView</tt> module and the <tt>ActionView::Base</tt> class which is the class of all view templates. Inside of <tt>ActionView::Base</tt> it makes an include to several helper modules:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
include Helpers, Rendering, Partials, Layouts, ::ERB::Util, Context
</pre>
</div>
</notextile>

<h5 id="actionview-helpers">5.33.5 <tt>ActionView::Helpers</tt></h5>
<p>This module, from <em>actionpack/lib/action_view/helpers.rb_, initially sets up the <tt>autoload</tt>&#8217;s for the various <tt>ActionView::Helpers</tt> modules (<span class="caps">TODO</span>: mysteriously not using <tt>autoload</em>under</tt></notextile>). This also sets up a <tt>ClassMethods</tt> module which is included automatically into wherever <tt>ActionView::Helpers</tt> is included by defining a <tt>self.included</tt> method:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def self.included(base)
    base.extend(ClassMethods)
  end

  module ClassMethods
    include SanitizeHelper::ClassMethods
  end
</pre>
</div>
</notextile>

<p>Inside of <tt>SanitizeHelper::ClassMethods</tt> it defines, of course, methods for assisting with sanitizing in Rails such as <tt>link_sanitizer</tt> which is used by the <tt>strip_links</tt> method.</p>
<p>Afterwards this includes the <tt>ActiveSupport::Benchmarkable</tt> which is used for benchmarking how long a specific thing takes in a view. The method is simply <tt>benchmark</tt> and can be used like this:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
benchmark(&quot;potentially long running thing&quot;) do
    Post.count
  end
</pre>
</div>
</notextile>

<p>The <a href="http://api.rails.info/classes/ActiveSupport/Benchmarkable.html#M000607">documentation</a> is great about explaining what precisely this does. (<span class="caps">TODO</span>: replace link with real documentation link when it becomes available.)</p>
<p>This module is also included into Active Record and <tt>AbstractController</tt>, meaning you can also use the <tt>benchmark</tt> method in these methods.</p>
<p>After including <tt>ActiveSupport::Benchmarkable</tt>, the helpers which we have declared to be <tt>autoload</tt>&#8216;d are included. I will not go through and cover what each of these helpers do, as their names should be fairly explicit about it, and it&#8217;s not really within the scope of this guide.</p>
<h5 id="actionview-rendering">5.33.6 <tt>ActionView::Rendering</tt></h5>
<p>This module, from <em>actionpack/lib/action_view/render/rendering.rb</em> defines a method you may be a little too familiar with: <tt>render</tt>. This is the <tt>render</tt> use for rendering all kinds of things, such as partials, templates and text.</p>
<h5 id="actionview-partials">5.33.7 <tt>ActionView::Partials</tt></h5>
<p>This module, from <em>actionpack/lib/action_view/render/partials.rb</em>, defines <tt>ActionView::Partials::PartialRenderer</tt> which you can probably guess is used for rendering partials.</p>
<h5 id="actionview-layouts">5.33.8 <tt>ActionView::Layouts</tt></h5>
<p>This module, from <em>actionpack/lib/action_view/render/layouts.rb_, defines <tt>ActionView::Layouts</tt> which defines methods such as <tt>find</em>layout</tt></notextile> for locating layouts.</p>
<h5 id="erb-util">5.33.9 <tt>ERB::Util</tt></h5>
<p>The <tt>ERB::Util</tt> module from Ruby core, as the document describes it: &#8220;A utility module for conversion routines, often handy in <span class="caps">HTML</span> generation&#8221;. It offers two methods <tt>html_escape</tt> and <tt>url_encode</tt>, with a third called <tt>json_escape</tt> being added in by the requirement of <em>actionpack/lib/active_support/core_ext/string/output_saftey.rb</em> earlier. As explained earlier, <tt>html_escape</tt> is overridden to return a string marked as safe.</p>
<h5 id="actionview-context">5.33.10 <tt>ActionView::Context</tt></h5>
<p><span class="caps">TODO</span>: Not entirely sure what this is all about. Something about the context of view rendering&#8230; can&#8217;t work it out.</p>
<h5 id="action-view-railtie">5.33.11 Action View Railtie</h5>
<p>Now that <em>actionpack/lib/action_view.rb</em> has been required, the next step is to <tt>require 'rails'</tt>, but this will be skipped as the file was required by <em>railties/lib/rails/all.rb</em> way back in the beginnings of the initialization process.</p>
<p>Next, the Railtie itself is defined:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
module ActionView
    class Railtie &lt; Rails::Railtie
      railtie_name :action_view

      require &quot;action_view/railties/log_subscriber&quot;
      log_subscriber ActionView::Railties::LogSubscriber.new

      initializer &quot;action_view.cache_asset_timestamps&quot; do |app|
        unless app.config.cache_classes
          ActionView.base_hook do
            ActionView::Helpers::AssetTagHelper.cache_asset_timestamps = false
          end
        end
      end
    end
  end
</pre>
</div>
</notextile>

<p>The <tt>ActionView::LogSubscriber</tt> sets up a method called <tt>render_template</tt> which is called when a template is rendered. <span class="caps">TODO</span>: Templates only or partials and layouts also? I would imagine these fall under the templates category, but there needs to research to ensure this is correct.</p>
<p>The sole initializer defined here, <em>action_view.cache_asset_timestamps</em> is responsible for caching the timestamps on the ends of your assets. If you&#8217;ve ever seen a link generated by <tt>image_tag</tt> or <tt>stylesheet_link_tag</tt> you would know that I mean that this timestamp is the number after the <em>?</em> in this example: <em>/javascripts/prototype.js?1265442620_. This initializer will do nothing if <tt>cache</em>classes</tt></notextile> is set to false in any of your application&#8217;s configuration. <span class="caps">TODO</span>: Elaborate.</p>
<h4 id="action-mailer-railtie">5.34 Action Mailer Railtie</h4>
<p>The Action Mailer Railtie is responsible for including all the emailing functionality into Rails by way of the Action Mailer gem itself. Action Mailer is:</p>
<p>Action Mailer is a framework for designing email-service layers. These layers
are used to consolidate code for sending out forgotten passwords, welcome
wishes on signup, invoices for billing, and any other use case that requires
a written notification to either a person or another system.</p>
<p>Action Mailer is in essence a wrapper around Action Controller and the
Mail gem.  It provides a way to make emails using templates in the same
way that Action Controller renders views using templates.</p>
<p><span class="caps">TODO</span>: Quotify.</p>
<h5 id="require-action_mailer-railtie">5.34.1 <tt>require 'action_mailer/railtie'</tt></h5>
<p>This file first makes two requires:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require &quot;action_mailer&quot;
  require &quot;rails&quot;
</pre>
</div>
</notextile>

<p>The requires in <tt>action_mailer</tt> are already loaded or are core extensions:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require 'abstract_controller'
  require 'action_view'

  # Common Active Support usage in Action Mailer
  require 'active_support/core_ext/class'
  require 'active_support/core_ext/object/blank'
  require 'active_support/core_ext/array/uniq_by'
  require 'active_support/core_ext/module/attr_internal'
  require 'active_support/core_ext/module/delegation'
  require 'active_support/core_ext/string/inflections'
  require 'active_support/lazy_load_hooks'
</pre>
</div>
</notextile>

<p><em>abstract_controller</em> is covered in the &#8220;Action Controller Railtie&#8221; section. <span class="caps">TODO</span>: Cover AbstractController there and link to it.
<em>action_view</em> was required by the Action View Railtie and will not be required again.</p>
<p>For the core extensions you may reference the &#8220;Core Extensions&#8221; guide. <span class="caps">TODO</span>: Link to guide.</p>
<p><em>active_support/lazy_load_hooks</em> was covered earlier in the guide and since it has already been required at this point in the initialization process, it will not be required again.</p>
<p>The <tt>require "rails"</tt> is referencing the <em>railties/lib/rails.rb</em> file which was included back in <span class="caps">TODO</span>: link to section.</p>
<p><em>actionmailer/lib/action_mailer.rb</em> then goes on to define the <tt>ActionMailer</tt> module:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
module ActionMailer
    extend ::ActiveSupport::Autoload

    autoload :AdvAttrAccessor
    autoload :Collector
    autoload :Base
    autoload :DeliveryMethods
    autoload :DeprecatedApi
    autoload :MailHelper
    autoload :OldApi
    autoload :Quoting
    autoload :TestCase
    autoload :TestHelper
  end
</pre>
</div>
</notextile>

<p>And a <tt>Text</tt> module too:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
module Text
    extend ActiveSupport::Autoload

    autoload :Format, 'text/format'
  end
</pre>
</div>
</notextile>

<p>which is used by the <tt>ActionMailer::MailerHelper</tt> method <tt>block_format</tt>:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def block_format(text)
    formatted = text.split(/\n\r\n/).collect { |paragraph|
      Text::Format.new(
        :columns =&gt; 72, :first_indent =&gt; 2, :body_indent =&gt; 2, :text =&gt; paragraph
      ).format
    }.join(&quot;\n&quot;)

    # Make list points stand on their own line
    formatted.gsub!(/[ ]*([*]+) ([^*]*)/) { |s| &quot;  #{$1} #{$2.strip}\n&quot; }
    formatted.gsub!(/[ ]*([#]+) ([^#]*)/) { |s| &quot;  #{$1} #{$2.strip}\n&quot; }

    formatted
  end
</pre>
</div>
</notextile>

<h5 id="action-mailer-railtie">5.34.2 Action Mailer Railtie</h5>
<p>The Railtie defines the <tt>log_subscriber</tt> as <tt>ActionMailer::Railties::LogSubscriber.new</tt>, with this class having two logging methods: one for delivery called <tt>deliver</tt> and one for receipt called <tt>receive</tt>.</p>
<p>The initializers defined in this Railtie are:</p>
<ul>
	<li>action_mailer.url_for</li>
	<li>action_mailer.logger</li>
	<li>action_mailer.set_configs</li>
</ul>
<p>These are covered later on the Initialization section. <span class="caps">TODO</span>: first write then link to Initialization section.</p>
<h4 id="active-resource-railtie">5.35 Active Resource Railtie</h4>
<p>The Active Resource Railtie is responsible for creating an interface into remote sites that offer a <span class="caps">REST</span> <span class="caps">API</span>. The Active Resource Railtie depends on Active Support and Active Model.</p>
<h5 id="require-active_resource-railtie">5.35.1 <tt>require 'active_resource/railtie'</tt></h5>
<p>This file defines the Active Resource Railtie:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require &quot;active_resource&quot;
  require &quot;rails&quot;

  module ActiveResource
    class Railtie &lt; Rails::Railtie
      railtie_name :active_resource

      require &quot;active_resource/railties/log_subscriber&quot;
      log_subscriber ActiveResource::Railties::LogSubscriber.new

      initializer &quot;active_resource.set_configs&quot; do |app|
        app.config.active_resource.each do |k,v|
          ActiveResource::Base.send &quot;#{k}=&quot;, v
        end
      end
    end
  end
</pre>
</div>
</notextile>

<p>The <tt>require 'rails'</tt> has already been done back in <span class="caps">TODO</span>: link to section.</p>
<h5 id="require-active_resource">5.35.2 <tt>require 'active_resource'</tt></h5>
<p>This file, <em>activeresource/lib/active_resource.rb_, defines the <tt>ActiveResource</tt> module, first off this will add the path to Active Support and Active Model to the load path if it&#8217;s not already there, then require both <tt>active_support</tt> (<em>activesupport/lib/active_support.rb_) and <tt>active_model</tt> (_activemodel/lib/active</em>model.rb</em>)</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
activesupport_path = File.expand_path('../../../activesupport/lib', __FILE__)
  $:.unshift(activesupport_path) if File.directory?(activesupport_path) &amp;&amp; !$:.include?(activesupport_path)

  activemodel_path = File.expand_path('../../../activemodel/lib', __FILE__)
  $:.unshift(activemodel_path) if File.directory?(activemodel_path) &amp;&amp; !$:.include?(activemodel_path)

  require 'active_support'
  require 'active_model'

  module ActiveResource
    extend ActiveSupport::Autoload

    autoload :Base
    autoload :Connection
    autoload :CustomMethods
    autoload :Formats
    autoload :HttpMock
    autoload :Observing
    autoload :Schema
    autoload :Validations
  end
</pre>
</div>
</notextile>

<h5 id="active-resource-railtie">5.35.3 Active Resource Railtie</h5>
<p>The Railtie itself is fairly short as Active Resource is the smallest component of Rails.</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
module ActiveResource
    class Railtie &lt; Rails::Railtie
      railtie_name :active_resource

      require &quot;active_resource/railties/log_subscriber&quot;
      log_subscriber ActiveResource::Railties::LogSubscriber.new

      initializer &quot;active_resource.set_configs&quot; do |app|
        app.config.active_resource.each do |k,v|
          ActiveResource::Base.send &quot;#{k}=&quot;, v
        end
      end
    end
  end
</pre>
</div>
</notextile>

<p>The Railtie defines the <tt>log_subscriber</tt> as <tt>ActiveResource::Railties::LogSubscriber.new</tt> which has one method defined: <tt>request</tt>. <tt>request</tt> is used whenever a request is made to an external service.</p>
<p>There is only one initializer defined here: <tt>set_configs</tt>. This is covered later in the Initialization section.</p>
<h4 id="actiondispatch-railtie">5.36 ActionDispatch Railtie</h4>
<p>ActionDispatch handles all dispatch work for Rails. It interfaces with Action Controller to determine what action to undertake when a request comes in. <span class="caps">TODO</span>: I would quote the <span class="caps">README</span> but it is strangely absent. Flyin&#8217; blind here!</p>
<p>The ActionDispatch Railtie was previously required when we called <tt>require 'rails'</tt>, but we will cover the Railtie here too.</p>
<p>ActionDispatch depends on Active Support.</p>
<h5 id="require-action_dispatch-railtie">5.36.1 <tt>require 'action_dispatch/railtie'</tt></h5>
<p>This file defines the ActionDispatch Railtie:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require &quot;action_dispatch&quot;
  require &quot;rails&quot;

  module ActionDispatch
    class Railtie &lt; Rails::Railtie
      railtie_name :action_dispatch

      config.action_dispatch.x_sendfile_header = &quot;X-Sendfile&quot;
      config.action_dispatch.ip_spoofing_check = true

      # Prepare dispatcher callbacks and run 'prepare' callbacks
      initializer &quot;action_dispatch.prepare_dispatcher&quot; do |app|
        # TODO: This used to say unless defined?(Dispatcher). Find out why and fix.
        require 'rails/dispatcher'
        ActionDispatch::Callbacks.to_prepare { app.routes_reloader.reload_if_changed }
      end
    end
  end
</pre>
</div>
</notextile>

<p>The <tt>require 'rails'</tt> has already been done back in <span class="caps">TODO</span>: link to section.</p>
<h5 id="require-action_dispatch">5.36.2 <tt>require 'action_dispatch'</tt></h5>
<p>This file was already loaded earlier in the initialization process. <span class="caps">TODO</span>: link to it.</p>
<h5 id="actiondispatch-railtie">5.36.3 ActionDispatch Railtie</h5>
<p>The ActionDispatch Railtie is almost as short as the Active Resource Railtie:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require &quot;action_dispatch&quot;
  require &quot;rails&quot;

  module ActionDispatch
    class Railtie &lt; Rails::Railtie
      railtie_name :action_dispatch

      config.action_dispatch.x_sendfile_header = &quot;X-Sendfile&quot;
      config.action_dispatch.ip_spoofing_check = true

      # Prepare dispatcher callbacks and run 'prepare' callbacks
      initializer &quot;action_dispatch.prepare_dispatcher&quot; do |app|
        # TODO: This used to say unless defined?(Dispatcher). Find out why and fix.
        require 'rails/dispatcher'
        ActionDispatch::Callbacks.to_prepare { app.routes_reloader.reload_if_changed }
      end
    end
  end
</pre>
</div>
</notextile>

<p>The <tt>config</tt> method here is from <tt>Rails::Railtie</tt> and pertains to your application&#8217;s configuration. In this case, it is setting up some defaults which you can later override in <em>config/application.rb</em>.</p>
<p>This Railtie does not define a <tt>log_subscriber</tt> and only defines one initializer: <tt>prepare_dispatcher</tt>.</p>
<h3 id="return-to-_config-application-rb_">6 Return to <em>config/application.rb</em></h3>
<p>Now that Rails has finished loading all the Railties by way of <tt>require 'rails/all'</tt> Rails can now move on to the next line:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Bundler.require :default, Rails.env
</pre>
</div>
</notextile>

<div class='note'><p>It is worth mentioning here that you are not tied to using Bundler with Rails 3, but it is (of course) advised that you do. To &#8220;turn off&#8221; Bundler, comment out or remove the corresponding lines in <em>config/application.rb</em> and <em>config/boot.rb</em>.</p></div>
<p>Bundler was <tt>require</tt>&#8216;d back in <em>config/boot.rb</em>, and so that is what makes it available here. This guide does not dive into the internals of Bundler; it&#8217;s really it&#8217;s own separate guide.</p>
<p>The <tt>Bundler.require</tt> method adds all the gems not specified inside a <tt>group</tt> in the <tt>Gemfile</tt> and the ones specified in groups for the <tt>Rails.env</tt> (in this case, <em>development</em>), to the load path. This is how an application is able to find them.</p>
<p>The rest of this file is spent defining your application&#8217;s main class. This is it without the comments:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
module YourApp
    class Application &lt; Rails::Application
      config.encoding = &quot;utf-8&quot;
      config.filter_parameters += [:password]
    end
  end
</pre>
</div>
</notextile>

<h3 id="return-to-rails">7 Return to Rails</h3>
<p>On the surface, this looks like a simple class inheritance. There&#8217;s more underneath though. back in <tt>Rails::Application</tt>, the <tt>inherited</tt> method is defined:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def inherited(base)
    raise &quot;You cannot have more than one Rails::Application&quot; if Rails.application
    super
    Rails.application = base.instance
  end
</pre>
</div>
</notextile>

<p>We do not already have a <tt>Rails.application</tt>, so instead this resorts to calling <tt>super</tt>. <tt>Rails::Application</tt> descends from <tt>Rails::Engine</tt> and so will call the <tt>inherited</tt> method in <tt>Rails::Engine</tt> (in <em>railties/lib/rails/engine.rb_), but before that it&#8217;s important to note that <tt>called_from</tt> is defined an <tt>attr_accessor</tt> on <tt>Rails::Engine</tt> and that <tt>YourApp::Application</tt> is not an <tt>abstract</em>railtie</tt></notextile>:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def inherited(base)
    unless base.abstract_railtie?
      base.called_from = begin
        # Remove the line number from backtraces making sure we don't leave anything behind
        call_stack = caller.map { |p| p.split(':')[0..-2].join(':') }
        File.dirname(call_stack.detect { |p| p !~ %r[railties[\w\-\.]*/lib/rails|rack[\w\-\.]*/lib/rack] })
      end
    end

    super
  end
</pre>
</div>
</notextile>

<p>This <tt>called_from</tt> setting looks a little overwhelming to begin with, but the short end of it is that it returns your application&#8217;s root, something like: <em>/home/you/yourapp_. After <tt>called</em>from</tt></notextile> has been set, <tt>super</tt> is again called and this means the <tt>Rails::Railtie#inherited</tt> method (in <em>railties/lib/rails/railtie.rb</em>):</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def inherited(base)
    unless base.abstract_railtie?
      base.send(:include, self::Configurable)
      subclasses &lt;&lt; base
    end
  end
</pre>
</div>
</notextile>

<p>Again, <tt>YourApp::Application</tt> will return false for <tt>abstract_railtie</tt> and so the code inside the <tt>unless</tt> will be ran. The first line:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
base.send(:include, self::Configurable)
</pre>
</div>
</notextile>

<p>includes the <tt>self::Configurable</tt> module, with self being <tt>Rails::Application</tt> in this context:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
module Rails
    class Application
      module Configurable
        def self.included(base)
          base.extend ClassMethods
        end

        module ClassMethods
          def inherited(base)
            raise &quot;You cannot inherit from a Rails::Application child&quot;
          end
        end

        def config
          @config ||= Application::Configuration.new(self.class.find_root_with_flag(&quot;config.ru&quot;, Dir.pwd))
        end
      end
    end
  end
</pre>
</div>
</notextile>

<p>The inclusion of the <tt>Rails::Application::Configurable</tt> module triggers the <tt>included</tt> method in here which extends <tt>YourApp::Application</tt> with the <tt>Rails::Application::Configurable::ClassMethods</tt>.</p>
<p>Now that the chain of <tt>super</tt> calls is done, we&#8217;ll go back to the original <tt>inherited</tt> method in <tt>Rails::Application</tt> and the final line in this method:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Rails.application = base.instance
</pre>
</div>
</notextile>

<p><tt>base</tt> in this case is <tt>YourApp::Application</tt> and calling <tt>instance</tt> on this will return an instance of <tt>YourApp::Application</tt> through the <tt>instance</tt> method defined here:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def instance
    if self == Rails::Application
      Rails.application
    else
      @@instance ||= new
    end
  end
</pre>
</div>
</notextile>

<p><tt>self</tt> in this case is <tt>YourApp::Application</tt>, so it won&#8217;t match to <tt>Rails::Application</tt> so instead the <tt>new</tt> method is called which calls the <tt>initialize</tt> method.</p>
<h3 id="firing-it-up">8 Firing it up!</h3>
<p>Now that we&#8217;ve covered the boot process of Rails the next line best to cover would be what happens after <em>script/rails</em> has loaded <em>config/boot.rb</em>. That&#8217;s quite simply that it then <tt>require 'rails/commands'</tt> which is located at <em>railties/lib/rails/commands.rb</em>. Remember how <tt>exec</tt> passed the arguments to <tt>script/rails</tt>? This is where they&#8217;re used. <em>rails/commands.rb</em> is quite a large file in Rails 3, as it contains all the Rails commands like console, about, generate and, of course, server. Because we&#8217;ve called <tt>rails server</tt> the first argument in <tt>ARGV</tt> is of course <tt>"server"</tt>. So assuming this we can determine that the <tt>ARGV.shift</tt> in <em>commands.rb</em> is going to return <tt>"server"</tt>, therefore it&#8217;ll match this <tt>when</tt>:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
when 's', 'server'
  require 'rails/commands/server'
  Dir.chdir(ROOT_PATH)
  Rails::Server.start
</pre>
</div>
</notextile>

<p>The keen-eyed observer will note that this <tt>when</tt> also specifies the argument could also be simply <tt>'s'</tt> thereby making the full command <tt>rails s</tt>. This is the same with the other commands with <tt>generate</tt> becoming <tt>g</tt>, <tt>console</tt> becoming <tt>c</tt> and <tt>dbconsole</tt> becoming <tt>db</tt>.</p>
<p>This code here ensures we are at the <tt>ROOT_PATH</tt> of our application (this constant was defined in <em>script/rails</em>) and then calls <tt>Rails::Server.start</tt>. <tt>Rails::Server</tt> descends from <tt>Rack::Server</tt> which is defined in the rack gem. The <tt>Rails::Server.start</tt> method is defined like this:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def start
    ENV[&quot;RAILS_ENV&quot;] = options[:environment]

    puts &quot;=&gt; Booting #{ActiveSupport::Inflector.demodulize(server)}&quot;
    puts &quot;=&gt; Rails #{Rails.version} application starting in #{Rails.env} on http://#{options[:Host]}:#{options[:Port]}&quot;
    puts &quot;=&gt; Call with -d to detach&quot; unless options[:daemonize]
    trap(:INT) { exit }
    puts &quot;=&gt; Ctrl-C to shutdown server&quot; unless options[:daemonize]

    super
  ensure
    puts 'Exiting' unless options[:daemonize]
  end
</pre>
</div>
</notextile>

<p>We can see here that there is usual output indicating that the server is booting up.</p>
<p>How the <tt>options</tt> variable gets set and how Rack starts the server up is covered in the next section.</p>
<h3 id="racking-it-up">9 Racking it up!</h3>
<p>This <tt>Rack::Server.start</tt> method is defined like this:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def self.start
    new.start
  end
</pre>
</div>
</notextile>

<p><tt>new</tt> as you know calls <tt>initialize</tt> in a class, and that is defined like this:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def initialize(options = nil)
    @options = options
  end
</pre>
</div>
</notextile>

<p>And then <tt>options</tt>, which are the options referenced by the <tt>start</tt> method in <tt>Rails::Server</tt>.</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def options
    @options ||= parse_options(ARGV)
  end
</pre>
</div>
</notextile>

<p>And <tt>parse_options</tt>:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def parse_options(args)
    options = default_options

    # Don't evaluate CGI ISINDEX parameters.
    # http://hoohoo.ncsa.uiuc.edu/cgi/cl.html
    args.clear if ENV.include?(&quot;REQUEST_METHOD&quot;)

    options.merge! opt_parser.parse! args
    options
  end
</pre>
</div>
</notextile>

<p>And <tt>default_options</tt>:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def default_options
    {
      :environment =&gt; &quot;development&quot;,
      :pid         =&gt; nil,
      :Port        =&gt; 9292,
      :Host        =&gt; &quot;0.0.0.0&quot;,
      :AccessLog   =&gt; [],
      :config      =&gt; &quot;config.ru&quot;
    }
  end
</pre>
</div>
</notextile>

<p>Finally! We&#8217;ve arrived at <tt>default_options</tt> which leads into our next point quite nicely. After the object has been <tt>initialize</tt>&#8217;d, <tt>start</tt> is called:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def start
    if options[:debug]
      $DEBUG = true
      require 'pp'
      p options[:server]
      pp wrapped_app
      pp app
    end

    if options[:warn]
      $-w = true
    end

    if includes = options[:include]
      $LOAD_PATH.unshift *includes
    end

    if library = options[:require]
      require library
    end

    daemonize_app if options[:daemonize]
    write_pid if options[:pid]
    server.run wrapped_app, options
  end
</pre>
</div>
</notextile>

<p>We&#8217;re not debugging anything, so there goes the first 7 lines, we&#8217;re not warning, nor are we including, requiring, daemonising or writing out a pid file. That&#8217;s everything except the final line, which calls <tt>run</tt> with the <tt>wrapped_app</tt> which is then defined like this:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def wrapped_app
    @wrapped_app ||= build_app app
  end
</pre>
</div>
</notextile>

<p>and <tt>build_app</tt>&#8217;s first and only argument is <tt>app</tt> which is defined like this:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def app
    @app ||= begin
      if !::File.exist? options[:config]
        abort &quot;configuration #{options[:config]} not found&quot;
      end

      app, options = Rack::Builder.parse_file(self.options[:config], opt_parser)
      self.options.merge! options
      app
    end
  end
</pre>
</div>
</notextile>

<p><tt>options</tt> is a method we talked about a short while ago, which is just the set of default options. <tt>options[:config]</tt> in this context is therefore <em>config.ru</em> which coincidentally we have in our application! To get an application instance from this method <tt>Rack::Builder</tt> joins the fray with a call to <tt>parse_file</tt> on our <em>config.ru</em>:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def self.parse_file(config, opts = Server::Options.new)
    options = {}
    if config =~ /\.ru$/
      cfgfile = ::File.read(config)
      if cfgfile[/^#\\(.*)/] &amp;&amp; opts
        options = opts.parse! $1.split(/\s+/)
      end
      cfgfile.sub!(/^__END__\n.*/, '')
      app = eval &quot;Rack::Builder.new {( &quot; + cfgfile + &quot;\n )}.to_app&quot;,
        TOPLEVEL_BINDING, config
    else
      require config
      app = Object.const_get(::File.basename(config, '.rb').capitalize)
    end
    return app, options
  end
</pre>
</div>
</notextile>

<p>First this reads your config file and checks it for <tt>#\</tt> at the beginning. This is supported if you want to pass options into the <tt>Rack::Server</tt> instance that you have and can be used like this:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
#\\ -E production
  # This file is used by Rack-based servers to start the application.

  require ::File.expand_path('../config/environment',  __FILE__)
  run YourApp::Application.instance
</pre>
</div>
</notextile>

<p><span class="caps">TODO</span>: Is the above correct? I am simply guessing!</p>
<p>After that it removes all the content after any <tt>__END__</tt> in your <em>config.ru</em> (<span class="caps">TODO</span>: because? Is this so it doesn&#8217;t get eval&#8217;d?) and then evals the content of this file which, as you&#8217;ve seen is quite simple. The code that&#8217;s first evaluated would be the require to the <em>config/environment.rb</em> file, which leads into the next section.</p>
<h3 id="_config-environment-rb_">10 <em>config/environment.rb</em></h3>
<p>Now that we&#8217;ve seen that <em>rails/server</em> gets to <em>config/environment.rb</em> via Rack&#8217;s requiring of it and Passenger requires it straight off the line. We&#8217;ve covered the boot process of Rails and covered the beginnings of a Rack server starting up. We have reached a common path for both <em>rails/server</em> and Passenger now, so let&#8217;s investigate what <em>config/environment.rb</em> does.</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
# Load the rails application
  require File.expand_path('../application', __FILE__)

  # Initialize the rails application
  YourApp::Application.initialize!
</pre>
</div>
</notextile>

<p>As you can see, there&#8217;s a require in here for <em>config/application.rb</em>, and this file looks like this:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
module YourApp
    class Application &lt; Rails::Application
      # Settings in config/environments/* take precedence over those specified here.
      # Application configuration should go into files in config/initializers
      # -- all .rb files in that directory are automatically loaded.

      # Add additional load paths for your own custom dirs
      # config.load_paths += %W( #{config.root}/extras )

      # Only load the plugins named here, in the order given (default is alphabetical).
      # :all can be used as a placeholder for all plugins not explicitly named
      # config.plugins = [ :exception_notification, :ssl_requirement, :all ]

      # Activate observers that should always be running
      # config.active_record.observers = :cacher, :garbage_collector, :forum_observer

      # Set Time.zone default to the specified zone and make Active Record auto-convert to this zone.
      # Run &quot;rake -D time&quot; for a list of tasks for finding time zone names. Default is UTC.
      # config.time_zone = 'Central Time (US &amp; Canada)'

      # The default locale is :en and all translations from config/locales/*.rb,yml are auto loaded.
      # config.i18n.load_path += Dir[Rails.root.join('my', 'locales', '*.{rb,yml}')]
      # config.i18n.default_locale = :de

      # Configure generators values. Many other options are available, be sure to check the documentation.
      # config.generators do |g|
      #   g.orm             :active_record
      #   g.template_engine :erb
      #   g.test_framework  :test_unit, :fixture =&gt; true
      # end
    end
  end
</pre>
</div>
</notextile>

<p>These options (and their siblings) are explained in a later section. What&#8217;s important to note for this file currently is that this is where the <tt>YourApp::Application</tt> class is initialized and that it&#8217;s a subclass of <tt>Rails::Application</tt>. This is the first point where your application begins to initialize Rails and as you can see all of this is configuration stuff which your initializers and really, the rest of your application will depend on. These options and what they do will be covered later.</p>
<h3 id="rails-initialization-process">11 Rails Initialization Process</h3>
<p>Now begins the actual initialization of Rails. Previously we have covered how <em>rails server</em> and Passenger get to this stage and the parts of Rails that they have both loaded.</p>
<h3 id="rails-application">12 <tt>Rails::Application</tt></h3>
<p>The first steps for the initialization process of Rails begins when <tt>YourApp::Application</tt> descends from <tt>Rails::Application</tt>. The <tt>Rails::Application</tt> class descends from <tt>Rails::Engine</tt> class which itself descends from <tt>Rails::Railtie</tt> defined in <em>railties/lib/rails/railtie.rb</em>. Along this fantastical chain of superclasses, there&#8217;s defined a couple of inherited class methods. These methods just so happen to be called when a class inherits from (aka: is made a subclass of) this class. This first one is for <tt>Rails::Application</tt>:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def inherited(base)
    raise &quot;You cannot have more than one Rails::Application&quot; if Rails.application
    super
    Rails.application = base.instance
  end
</pre>
</div>
</notextile>

<p>This goes up the chain by using <tt>super</tt> to calling <tt>Rails::Engine.inherited</tt>:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def inherited(base)
    unless abstract_railtie?(base)
      base.called_from = begin
        call_stack = caller.map { |p| p.split(':').first }
        File.dirname(call_stack.detect { |p| p !~ %r[railties/lib/rails|rack/lib/rack] })
      end
    end

    super
  end
</pre>
</div>
</notextile>

<p><tt>called_from</tt> references where this code was called from. This is covered later on in the &#8220;Bootstrap Initializers&#8221; section.</p>
<p>Which then calls <tt>Rails::Railtie.inherited</tt>:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def inherited(base)
    unless abstract_railtie?(base)
      base.send(:include, self::Configurable)
      subclasses &lt;&lt; base
    end
  end
</pre>
</div>
</notextile>

<p>This <tt>inherited</tt> first includes the <tt>Rails::Configurable</tt> module on <tt>base</tt>, which is <tt>YourApp::Application</tt>. This module defines the <tt>config</tt> method on <tt>YourApp::Application</tt>, and now it&#8217;s starting to come together. You may notice that in your <tt>config/application.rb</tt> file there&#8217;s a <tt>config</tt> method called there. This is the method from <tt>Rails::Configurable</tt>.</p>
<p>Then this adds to <tt>Rails::Railtie.subclasses</tt> your application&#8217;s class because&#8230; <span class="caps">TODO</span>: explain.</p>
<p>With <tt>Rails::Railtie.inherited</tt> out of the way, and that being the last thing to do in <tt>Rails::Engine.inherited</tt> we return to <tt>Rails::Application.inherited</tt> which calls the following:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Rails.application = base.instance
</pre>
</div>
</notextile>

<p>As you already know, <tt>base</tt> is <tt>YourApp::Application</tt> and now it&#8217;s calling the <tt>instance</tt> method on it. This method is defined in <tt>Rails::Application</tt> like this:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def instance
    if self == Rails::Application
      Rails.application
    else
      @@instance ||= new
    end
  end
</pre>
</div>
</notextile>

<p>The <tt>new</tt> method here simply creates a new <tt>Rails::Application</tt> and sets it to the <tt>@@instance</tt> class variable. No magic.</p>
<h3 id="your-application-s-configuration">13 Your Application&#8217;s Configuration</h3>
<p>Now that <tt>inherited</tt> has finished doing its job, next up in <em>config/application.rb</em> is the call to the <tt>config</tt> object&#8217;s methods. As explained before, this <tt>config</tt> object is an instance of <tt>Rails::Railtie::Configuration</tt>, put into place by the call of <tt>include Rails::Configurable</tt> back in <tt>Rails::Railtie.inherited</tt>. This defined it as such:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def config
    @config ||= Railtie::Configuration.new
  end
</pre>
</div>
</notextile>

<p>All the methods for <tt>Rails::Railtie::Configuration</tt> are defined like this in <em>railties/lib/rails/railtie/configuration.rb</em>:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require 'rails/configuration'

  module Rails
    class Railtie
      class Configuration
        include Rails::Configuration::Shared
      end
    end
  end
</pre>
</div>
</notextile>

<p>As you can probably guess here, the <tt>Rails::Configuration</tt> module is defined by <em>rails/configuration</em> (<em>railties/lib/rails/configuration.rb</em>).</p>
<h3 id="rails-configuration-shared">14 <tt>Rails::Configuration::Shared</tt></h3>
<p>In a standard application, the <tt>application.rb</tt> looks like this with all the comments stripped out:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require File.expand_path('../boot', __FILE__)

  module YourApp
    class Application &lt; Rails::Application
      config.filter_parameters &lt;&lt; :password
    end
  end
</pre>
</div>
</notextile>

<p>The <tt>config</tt> method being the one defined on <tt>Rails::Application::Configurable</tt>:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def config
    @config ||= Application::Configuration.new(self.class.find_root_with_flag(&quot;config.ru&quot;, Dir.pwd))
  end
</pre>
</div>
</notextile>

<p>The method <tt>find_with_root_flag</tt> is defined on <tt>Rails::Engine</tt> (the superclass of <tt>Rails::Application</tt>) and it will find the directory containing a certain flag. In this case it&#8217;s the <tt>config.ru</tt> file:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def find_root_with_flag(flag, default=nil)
    root_path = self.called_from

    while root_path &amp;&amp; File.directory?(root_path) &amp;&amp; !File.exist?(&quot;#{root_path}/#{flag}&quot;)
      parent = File.dirname(root_path)
      root_path = parent != root_path &amp;&amp; parent
    end

    root = File.exist?(&quot;#{root_path}/#{flag}&quot;) ? root_path : default
    raise &quot;Could not find root path for #{self}&quot; unless root

    RUBY_PLATFORM =~ /(:?mswin|mingw)/ ?
      Pathname.new(root).expand_path : Pathname.new(root).realpath
  end
</pre>
</div>
</notextile>

<p><tt>called_from</tt> goes through the <tt>caller</tt> which is the stacktrace of the current thread, in the case of your application it would go a little like this:</p>
<pre>
  /usr/local/lib/ruby/gems/1.9.1/gems/railties-3.0.0/lib/rails/application.rb:30:in `inherited'
  /home/you/yourapp/config/application.rb:4:in `&lt;module:TestApp&gt;'
  /home/you/yourapp/config/application.rb:3:in `&lt;top (required)&gt;'
  /usr/local/lib/ruby/gems/1.9.1/gems/activesupport-3.0.0/lib/active_support/dependencies.rb:167:in `require'
  /usr/local/lib/ruby/gems/1.9.1/gems/activesupport-3.0.0/lib/active_support/dependencies.rb:167:in `block in require'
  /usr/local/lib/ruby/gems/1.9.1/gems/activesupport-3.0.0/lib/active_support/dependencies.rb:537:in `new_constants_in'
  /usr/local/lib/ruby/gems/1.9.1/gems/activesupport-3.0.0/lib/active_support/dependencies.rb:167:in `require'
  /usr/local/lib/ruby/gems/1.9.1/gems/railties-3.0.0/lib/rails/commands.rb:33:in `&lt;top (required)&gt;'
  /usr/local/lib/ruby/gems/1.9.1/gems/activesupport-3.0.0/lib/active_support/dependencies.rb:167:in `require'
  /usr/local/lib/ruby/gems/1.9.1/gems/activesupport-3.0.0/lib/active_support/dependencies.rb:167:in `block in require'
  /usr/local/lib/ruby/gems/1.9.1/gems/activesupport-3.0.0/lib/active_support/dependencies.rb:537:in `new_constants_in'
  /usr/local/lib/ruby/gems/1.9.1/gems/activesupport-3.0.0/lib/active_support/dependencies.rb:167:in `require'
  /var/www/rboard/script/rails:10:in `&lt;main&gt;'
</pre>
<p><tt>called_from</tt> is defined in the <tt>inherited</tt> method for <tt>Rails::Engine</tt> which looks like this:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
base.called_from = begin
    call_stack = caller.map { |p| p.split(':').first }
    File.dirname(call_stack.detect { |p| p !~ %r[railties/lib/rails|rack/lib/rack] })
  end
</pre>
</div>
</notextile>

<p>The <tt>call_stack</tt> here is the <tt>caller</tt> output shown previously, minus everything after the first <tt>:</tt> on all the lines. The first path that matches this is <em>/usr/local/lib/ruby/gems/1.9.1/gems/railties-3.0.0/lib/rails</em>. Yours may vary slightly, but should always end in <em>railties-x.&#215;.x/lib/rails</em>.</p>
<p>The code in <tt>find_root_with_flag</tt> will go up this directory structure until it reaches the top, which in this case is <tt>/</tt>.</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
while root_path &amp;&amp; File.directory?(root_path) &amp;&amp; !File.exist?(&quot;#{root_path}/#{flag}&quot;)
    parent = File.dirname(root_path)
    root_path = parent != root_path &amp;&amp; parent
  end

  root = File.exist?(&quot;#{root_path}/#{flag}&quot;) ? root_path : default
  raise &quot;Could not find root path for #{self}&quot; unless root
</pre>
</div>
</notextile>

<p><span class="caps">TODO</span>: What is all this for?</p>
<p>At the root of the system it looks for <tt>config.ru</tt>. <span class="caps">TODO</span>: Why? Obviously it&#8217;s not going to find it, so it uses the <tt>default</tt> option we&#8217;ve specified which is <tt>Dir.pwd</tt> which will default to the root folder of your Rails application. This path is then passed to <tt>Rails::Application::Configuration.new</tt>. <tt>Rails::Application::Configuration</tt> descends from <tt>Rails::Engine::Configuration</tt> and the <tt>initialize</tt> method goes like this:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def initialize(*)
    super
    @allow_concurrency   = false
    @colorize_logging    = true
    @filter_parameters   = []
    @dependency_loading  = true
    @serve_static_assets = true
    @time_zone           = &quot;UTC&quot;
    @consider_all_requests_local = true
  end
</pre>
</div>
</notextile>

<p>The <tt>super</tt> method here is the <tt>initialize</tt> method in <tt>Rails::Engine::Configuration</tt>:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def initialize(root=nil)
    @root = root
  end
</pre>
</div>
</notextile>

<p>Here, the <tt>@root</tt> variable is assigned the path of your application and then the remainder of <tt>Rails::Application::Configuration.initialize</tt> is ran, setting up a few instance variables for basic configuration, including one for <tt>@filter_parameters</tt>.</p>
<p>Now with the <tt>config</tt> option set up, we can go onwards and call <tt>filter_parameters</tt> on it. This <tt>filter_parameters</tt> method is not defined on <tt>Rails::Configuration::Shared</tt> and actually falls to the <tt>method_missing</tt> defined there instead:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def method_missing(name, *args, &amp;blk)
     if name.to_s =~ config_key_regexp
       return $2 == '=' ? options[$1] = args.first : options[$1]
     end
     super
   end
</pre>
</div>
</notextile>

<p>We&#8217;re not calling <tt>filter_parameters=</tt>, we&#8217;re calling <tt>filter_parameters</tt>, therefore it&#8217;ll be the second part of this ternary argument: <tt>options[$1]</tt>. The options method is defined like this:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def options
    @@options ||= Hash.new { |h,k| h[k] = ActiveSupport::OrderedOptions.new }
  end
</pre>
</div>
</notextile>

<p>OrderedOptions exists&#8230; <span class="caps">TODO</span>: explain.</p>
<p>So from this we can determine that our <tt>options</tt> hash now has a key for <tt>filter_parameters</tt> which&#8217;s value is an array consisting of a single symbol: <tt>:password</tt>. How this option manages to get into the <tt>@filter_parameters</tt> variable defined on the <tt>Rails::Application::Configuration.initialize</tt> method is explained later.</p>
<h3 id="application-configured">15 Application Configured!</h3>
<p>Now your application has finished being configured (at least in the sense of <em>config/application.rb</em>, there&#8217;s more to come!) in <em>config/environment.rb</em> the final line calls <tt>YourApp::Application.initalize!</tt>.</p>
<h3 id="initialization-begins">16 Initialization begins</h3>
<p>This is one of those magical uses of <tt>method_missing</tt> which, for the purposes of debugging, is something that you don&#8217;t expect to come across as often as you do and as a consequence you&#8217;ll spend a good portion of an hour looking for method definitions that don&#8217;t exist because <tt>method_missing</tt> is taking care of it. There&#8217;s some pretty crafty use of <tt>method_missing</tt> all over Rails and it&#8217;s encouraged to take note of its power.</p>
<p><tt>Rails::Application</tt> has a <tt>method_missing</tt> definition which does this:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def method_missing(*args, &amp;block)
    instance.send(*args, &amp;block)
  end
</pre>
</div>
</notextile>

<p>With our <tt>instance</tt> being our already initialized by the <tt>inherited</tt> method, this will just return the value of the <tt>@@instance</tt> variable, a <tt>Rails::Application</tt> object. Calling <tt>initialize!</tt> on this method does this:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def initialize!
    run_initializers(self)
    self
  end
</pre>
</div>
</notextile>

<p>The initializers it is talking about running here are the initializers for our application. The object passed in to <tt>run_initializers</tt> is <tt>YourApp::Application</tt>.</p>
<h3 id="run_initializers">17 <tt>run_initializers</tt></h3>
<p>This method begins the running of all the defined initializers. In the section &#8220;The Boot Process&#8221; we covered the loading sequence of Rails before any initialization happens and during this time we saw that the <tt>Rails::Railtie</tt> class includes the <tt>Initializable</tt> module. As we&#8217;ve also seen <tt>YourApp::Application</tt> is a descendant of this class, so it too has these methods.</p>
<p><tt>run_initializers</tt> looks like this:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def run_initializers(*args)
    return if instance_variable_defined?(:@ran)
    initializers.each do |initializer|
      initializer.run(*args)
    end
    @ran = true
  end
</pre>
</div>
</notextile>

<p>Here the <tt>initializers</tt> method is defined in <em>railties/lib/rails/application.rb</em>:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def initializers
    initializers = Bootstrap.initializers_for(self)
    railties.all { |r| initializers += r.initializers }
    initializers += super
    initializers += Finisher.initializers_for(self)
    initializers
  end
</pre>
</div>
</notextile>

<h3 id="bootstrap-initializers">18 <tt>Bootstrap</tt> initializers</h3>
<p>The first line here references a <tt>Bootstrap</tt> class we haven&#8217;t seen before. Or have we? The keen-eyed observer would have spotted an <tt>autoload</tt> for it at the top of <tt>Rails::Application</tt>:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
autoload :Bootstrap,      'rails/application/bootstrap'
</pre>
</div>
</notextile>

<p>Now that we&#8217;ve referenced that class, it will be required for us. You&#8217;ll notice inside this class that there&#8217;s an <tt>include Initializable</tt>, providing the afore-mentioned methods from this module. Inside this class a number of initializers are defined.</p>
<ul>
	<li>load_environment_config</li>
	<li>load_all_active_support</li>
	<li>preload_frameworks</li>
	<li>initialize_logger</li>
	<li>initialize_cache</li>
	<li>initialize_subscriber</li>
	<li>set_clear_dependencies_hook</li>
	<li>initialize_dependency_mechanism</li>
</ul>
<p>These are all defined using the <tt>initializer</tt> method:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def initializer(name, opts = {}, &amp;blk)
    raise ArgumentError, &quot;A block must be passed when defining an initializer&quot; unless blk
    opts[:after] ||= initializers.last.name unless initializers.empty? || initializers.find { |i| i.name == opts[:before] }
    initializers &lt;&lt; Initializer.new(name, nil, opts, &amp;blk)
  end
</pre>
</div>
</notextile>

<p>The <tt>initializers</tt> method defined here just references an <tt>@initializers</tt> variable:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def initializers
    @initializers ||= []
  end
</pre>
</div>
</notextile>

<p>As you can see from this method it will set <tt>opts[:after]</tt> if there are previously defined initializers. So we can determine from this that the order our initializers are defined in is the same order that they run in, but only by default. It is possible to change this by specifying an <tt>:after</tt> or <tt>:before</tt> option as we will see later on. Each initializer is its own instance of the <tt>Initializer</tt> class:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Initializer
    attr_reader :name, :block

    def initialize(name, context, options, &amp;block)
      @name, @context, @options, @block = name, context, options, block
    end

    def before
      @options[:before]
    end

    def after
      @options[:after]
    end

    def run(*args)
      @context.instance_exec(*args, &amp;block)
    end

    def bind(context)
      return self if @context
      Initializer.new(@name, context, @options, &amp;block)
    end
  end
</pre>
</div>
</notextile>

<p>Now that <tt>Rails::Application::Bootstrap</tt> has finished loading, we can continue on with our initialization. We saw that it called this:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
initializers = Bootstrap.initializers_for(self)
</pre>
</div>
</notextile>

<p>Calling <tt>initializers_for</tt>, defined like this:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def initializers_for(binding)
    Collection.new(initializers_chain.map { |i| i.bind(binding) })
  end
</pre>
</div>
</notextile>

<p>The <tt>binding</tt> argument here is <tt>YourApp::Application</tt> and this will return a new <tt>Initializer</tt> object for all the initializers in <tt>initializers_chain</tt> for this particular context. <tt>initializers_chain</tt> goes like this:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def initializers_chain
    initializers = Collection.new
    ancestors.reverse_each do |klass|
      next unless klass.respond_to?(:initializers)
      initializers = initializers + klass.initializers
    end
    initializers
  end
</pre>
</div>
</notextile>

<p>The ancestors list is relatively short for <tt>Rails::Application::Bootstrap</tt>, consisting of itself and <tt>Rails::Initializable</tt>. Rails will go through these ancestors in reverse and check them all if they <tt>respond_to?(:initializers)</tt>. <tt>Rails::Initializable</tt> does not and so it&#8217;s skipped. <tt>Rails::Application::Bootstrap</tt> of course does, and this is the list of initializers we covered earlier.</p>
<p>After <tt>initializers_chain</tt> is finished, then they are <tt>map</tt>&#8217;d like this, with the <tt>binding</tt> of course being <tt>YourApp::Application</tt> as explained previously.</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def initializers_for(binding)
    Collection.new(initializers_chain.map { |i| i.bind(binding) })
  end
</pre>
</div>
</notextile>

<p>Wow. All that to cover just the first line in the <tt>initializers</tt> method for <tt>Rails::Application</tt>.</p>
<h3 id="railties-initializers">19 Railties Initializers</h3>
<p>This section covers the loading of the initializers and we will go into depth for each initializer in the next section, as they make more sense explained in their chain.</p>
<p>The second line in <tt>Rails::Application#initializers</tt>:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def initializers
    railties.all { |r| initializers += r.initializers }
  end
</pre>
</div>
</notextile>

<p>calls <tt>railties</tt>, which is defined like this:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def railties
    @railties ||= Railties.new(config)
  end
</pre>
</div>
</notextile>

<p>This sets up a new <tt>Rails::Application::Railties</tt> object like this:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def initialize(config)
    @config = config
  end
</pre>
</div>
</notextile>

<p>And calls <tt>all</tt> on it:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def all(&amp;block)
    @all ||= railties + engines + plugins
    @all.each(&amp;block) if block
    @all
  end
</pre>
</div>
</notextile>

<p>This <tt>all</tt> method executes code on all the <tt>Rails::Railtie</tt> and <tt>Rails::Engine</tt> subclasses, retreived by the <tt>railties</tt> and <tt>engines</tt> methods defined right after <tt>all</tt>:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def railties
    @railties ||= ::Rails::Railtie.subclasses.map(&amp;:new)
  end

  def engines
    @engines ||= ::Rails::Engine.subclasses.map(&amp;:new)
  end
</pre>
</div>
</notextile>

<p>By default, the railties are:</p>
<ul>
	<li><tt>ActiveSupport::Railtie</tt></li>
	<li><tt>I18n::Railtie</tt></li>
	<li><tt>ActionDispatch::Railtie</tt></li>
	<li><tt>ActionController::Railtie</tt></li>
	<li><tt>ActiveRecord::Railtie</tt></li>
	<li><tt>ActionView::Railtie</tt></li>
	<li><tt>ActionMailer::Railtie</tt></li>
	<li><tt>ActiveResource::Railtie</tt></li>
	<li><tt>Rails::TestUnitRailtie</tt></li>
</ul>
<p>And these all descend from <tt>Rails::Railtie</tt>.</p>
<p>The default <tt>engines</tt> are <tt>[]</tt>.</p>
<p>The <tt>plugins</tt> method it calls is a little more complex:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def plugins
    @plugins ||= begin
      plugin_names = (@config.plugins || [:all]).map { |p| p.to_sym }
      Plugin.all(plugin_names, @config.paths.vendor.plugins)
    end
  end
</pre>
</div>
</notextile>

<p><tt>@config.paths</tt> is defined in the <tt>Rails::Application::Configuration</tt> like this:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def paths
    @paths ||= begin
      paths = super
      paths.app.controllers &lt;&lt; builtin_controller if builtin_controller
      paths.config.database    &quot;config/database.yml&quot;
      paths.config.environment &quot;config/environments&quot;, :glob =&gt; &quot;#{Rails.env}.rb&quot;
      paths.log                &quot;log/#{Rails.env}.log&quot;
      paths.tmp                &quot;tmp&quot;
      paths.tmp.cache          &quot;tmp/cache&quot;
      paths.vendor             &quot;vendor&quot;, :load_path =&gt; true
      paths.vendor.plugins     &quot;vendor/plugins&quot;

      if File.exists?(&quot;#{root}/test/mocks/#{Rails.env}&quot;)
        ActiveSupport::Deprecation.warn &quot;\&quot;RAILS_ROOT/test/mocks/#{Rails.env}\&quot; won't be added &quot; &lt;&lt;
          &quot;automatically to load paths anymore in future releases&quot;
        paths.mocks_path  &quot;test/mocks&quot;, :load_path =&gt; true, :glob =&gt; Rails.env
      end

      paths
    end
  end
</pre>
</div>
</notextile>

<p>When we call <tt>@config.paths.vendor.plugins</tt> it will return <tt>"vendor/plugins"</tt>.</p>
<p>If you&#8217;ve defined specific plugin requirements for your application in <em>config/application.rb</em> by using this code:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
config.plugins = [:will_paginate, :by_star]
</pre>
</div>
</notextile>

<p>or specific plugin loading using a similar statement such as this next one:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
config.plugins = [:will_paginate, :by_star, :all]
</pre>
</div>
</notextile>

<p>Then this is where the <tt>@config.plugins</tt> comes from. If you wish to load only certain plugins for your application, use the first example. If you wish to load certain plugins before the rest then the second example is what you would use.</p>
<p>If <tt>config.plugins</tt> is not defined then <tt>:all</tt> is specified in its place. Whatever the <tt>plugin_names</tt> is specified as, is passed to <tt>Plugin.all</tt> along with the path to the plugins, <tt>@config.path.vendor.plugins</tt> (which defaults to <em>vendor/plugins</em>):</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def self.all(list, paths)
    plugins = []
    paths.each do |path|
      Dir[&quot;#{path}/*&quot;].each do |plugin_path|
        plugin = new(plugin_path)
        next unless list.include?(plugin.name) || list.include?(:all)
        plugins &lt;&lt; plugin
      end
    end

    plugins.sort_by do |p|
      [list.index(p.name) || list.index(:all), p.name.to_s]
    end
  end
</pre>
</div>
</notextile>

<p>As we can see here it will go through the paths and for every folder in <em>vendor/plugins</em> and <tt>initialize</tt> a new <tt>Rails::Plugin</tt> object for each:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def initialize(root)
    @name = File.basename(root).to_sym
    config.root = root
  end
</pre>
</div>
</notextile>

<p>This sets the plugin name to be the same name as the folder so the plugin located at <em>vendor/plugins/by\_star_&#8217;s name is <tt>by</em>star</tt></notextile>. After that, the <tt>config</tt> object is initialized:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def config
    @config ||= Engine::Configuration.new
  end
</pre>
</div>
</notextile>

<p>and the root of the plugin defined as that folder. The reasoning for defining a <tt>root</tt> is so that the initializer called <tt>load_init_rb</tt> has some place to look for this file:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
initializer :load_init_rb, :before =&gt; :load_application_initializers do |app|
    file   = Dir[&quot;#{root}/{rails/init,init}.rb&quot;].first
    config = app.config
    eval(File.read(file), binding, file) if file &amp;&amp; File.file?(file)
  end
</pre>
</div>
</notextile>

<p>A little more on that later, however.</p>
<p>If the plugin is not included in the list then it moves on to the next one. For all plugins included in the list (or if <tt>:all</tt> is specified in the list) they are put into a <tt>plugins</tt> local variable which is then sorted:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
plugins.sort_by do |p|
    [list.index(p.name) || list.index(:all), p.name.to_s]
  end
</pre>
</div>
</notextile>

<p>The sort order is the same order as which they appear in the <tt>config.plugins</tt> setting, or in alphabetical order if there is no setting specified.</p>
<p>Now that we have our railties, engines, and plugins in a line we can finally get back to the <tt>all</tt> code:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def initializers
    railties.all { |r| initializers += r.initializers }
  end
</pre>
</div>
</notextile>

<p>This block will gather add the railties&#8217; initializers to it.</p>
<h3 id="engine-initializers">20 Engine Initializers</h3>
<p>The third line in this <tt>initializers</tt> method:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
initializers += super
</pre>
</div>
</notextile>

<p>The <tt>super</tt> method it&#8217;s referring to is of course <tt>Rails::Engine.initializers</tt>, which isn&#8217;t defined on the class but, as we have seen before, is defined on the <tt>Rails::Railtie</tt> class it inherits from through the <tt>Rails::Initializable</tt> module. Therefore we can determine the initializers to be added are now the ones defined in <tt>Rails::Engine</tt>.</p>
<h3 id="finisher-initializers">21 Finisher Initializers</h3>
<p>The final set of initializers in this chain are those in <tt>Rails::Finisher</tt>. This involves running any after initialize code, building the middleware stack and adding the route for <em>rails/info/properties</em>.</p>
<h3 id="running-the-initializers">22 Running the Initializers</h3>
<p>Now that we have all the initializers we can go back to the <tt>run_initializers</tt> in <tt>Rails::Initializable</tt>:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def run_initializers(*args)
    return if instance_variable_defined?(:@ran)
    initializers.each do |initializer|
      initializer.run(*args)
    end
    @ran = true
  end
</pre>
</div>
</notextile>

<p>Now we finally have all the <tt>initializers</tt> we can go through them and call <tt>run</tt>:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def run(*args)
    @context.instance_exec(*args, &amp;block)
  end
</pre>
</div>
</notextile>

<p>You may remember that the <tt>@context</tt> in this code is <tt>YourApp::Application</tt> and calling <tt>instance_exec</tt> on this class will make a new instance of it and execute the code within the <tt>&block</tt> passed to it. This code within the block is the code from all the initializers.</p>
<h3 id="bootstrap-initializers">23 Bootstrap Initializers</h3>
<p>These initializers are the very first initializers that will be used to get your application going.</p>
<h4 id="load_environment_config">23.1 <tt>load_environment_config</tt></h4>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
initializer :load_environment_config do
    require_environment!
  end
</pre>
</div>
</notextile>

<p>This quite simply makes a call to <tt>require_environment!</tt> which is defined like this in <tt>Rails::Application</tt>:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def require_environment!
    environment = config.paths.config.environment.to_a.first
    require environment if environment
  end
</pre>
</div>
</notextile>

<p>We&#8217;ve seen <tt>config.paths</tt> before when loading the plugins and they&#8217;re explained in more detail in the Bonus section at the end of this guide. <tt>config.enviroment</tt> for <tt>paths</tt> is defined like this:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
paths.config.environment &quot;config/environments&quot;, :glob =&gt; &quot;#{Rails.env}.rb&quot;
</pre>
</div>
</notextile>

<p><tt>Rails.env</tt> was defined way back in the boot process when <tt>railties/lib/rails.rb</tt> was required:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
module Rails
  class &lt;&lt; self

    ...

    def env
      @_env ||= ActiveSupport::StringInquirer.new(ENV[&quot;RAILS_ENV&quot;] || ENV[&quot;RACK_ENV&quot;] || &quot;development&quot;)
    end

    ...

  end
end
</pre>
</div>
</notextile>

<p>With <tt>ENV["RAILS_ENV"]</tt> and <tt>ENV["RACK_ENV"]</tt> not set to anything for our server booting process, this will default to <tt>"development"</tt>.</p>
<p>Therefore the path to this config file line would look like this with a substitution made:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
paths.config.environment &quot;config/environments&quot;, :glob =&gt; &quot;development.rb&quot;
</pre>
</div>
</notextile>

<p>This method returns a <tt>Path</tt> object (which acts as an <tt>Enumerable</tt>).</p>
<p>Back to <tt>require_environment</tt> now:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def require_environment!
    environment = config.paths.config.environment.to_a.first
    require environment if environment
  end
</pre>
</div>
</notextile>

<p>And we&#8217;ve determined that <tt>config.paths.config.environment</tt> is <tt>Path</tt> object, and calling <tt>to_a</tt> on that object calls <tt>paths</tt> because it&#8217;s <tt>alias</tt>&#8217;d at the bottom of the <tt>Path</tt> class definition:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
alias to_a paths
</pre>
</div>
</notextile>

<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def paths
    raise &quot;You need to set a path root&quot; unless @root.path
    result = @paths.map do |p|
      path = File.expand_path(p, @root.path)
      @glob ? Dir[File.join(path, @glob)] : path
    end
    result.flatten!
    result.uniq!
    result
  end
</pre>
</div>
</notextile>

<p>This returns an array of files according to our <tt>path</tt> and <tt>@glob</tt> which are <tt>config/environments</tt> and <tt>development.rb</tt> respectively, therefore we can determine that:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Dir[File.join(path, @glob)]
</pre>
</div>
</notextile>

<p>will return an <tt>Array</tt> containing one element, <tt>"config/enviroments/development.rb"</tt>. Of course when we call <tt>first</tt> on this Array we&#8217;ll get the first element and because that exists, we now <tt>require "config/environments/development.rb"</tt>.</p>
<p>This file contains the following by default:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
YourApp::Application.configure do
    # Settings specified here will take precedence over those in config/environment.rb

    # In the development environment your application's code is reloaded on
    # every request.  This slows down response time but is perfect for development
    # since you don't have to restart the webserver when you make code changes.
    config.cache_classes = false

    # Log error messages when you accidentally call methods on nil.
    config.whiny_nils = true

    # Show full error reports and disable caching
    config.consider_all_requests_local       = true
    config.action_view.debug_rjs             = true
    config.action_controller.perform_caching = false

    # Don't care if the mailer can't send
    config.action_mailer.raise_delivery_errors = false
  end
</pre>
</div>
</notextile>

<p>This <tt>configure</tt> method is an <tt>alias</tt> of <tt>class_eval</tt> on <tt>Rails::Application</tt>:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
alias   :configure :class_eval
</pre>
</div>
</notextile>

<p>therefore, the code inside of the <tt>configure</tt> is evaluated within the context of <tt>YourApp::Application</tt>.</p>
<p>The <tt>config</tt> object here is the same one that was set up when <em>config/application.rb</em> was loaded, therefore the methods called in this object will fall to the <tt>method_missing</tt> defined in <tt>Rails::Configuration::Shared</tt>:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def method_missing(name, *args, &amp;blk)
    if name.to_s =~ config_key_regexp
      return $2 == '=' ? options[$1] = args.first : options[$1]
    end
    super
  end
</pre>
</div>
</notextile>

<p>This time we are using methods ending in <tt>\=</tt>, so it will set the key in the <tt>options</tt> to be the value specified. The first couple of options, <tt>cache_classes</tt>, <tt>whiny_nils</tt>, <tt>consider_all_requests_local</tt> are just simple keys on the <tt>options</tt>. If you recall how options were setup then you may be able to work out how the remaining <tt>action_view</tt>, <tt>action_controller</tt> and <tt>action_mailer</tt> methods work.</p>
<p>Firstly, we&#8217;ll cover how <tt>config_key_regexp</tt> is defined:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def config_key_regexp
    bits = config_keys.map { |n| Regexp.escape(n.to_s) }.join('|')
    /^(#{bits})(?:=)?$/
  end
</pre>
</div>
</notextile>

<p>And also <tt>config_keys</tt>:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def config_keys
    (Railtie.railtie_names + Engine.engine_names).map { |n| n.to_s }.uniq
  end
</pre>
</div>
</notextile>

<p><tt>config_keys</tt> in here returns:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
[:active_support, :i18n, :action_dispatch, :action_view, :action_controller, :active_record, :action_mailer, :active_resource, :test_unit]
</pre>
</div>
</notextile>

<p>With all of those keys coming from <tt>Railtie::railtie_names</tt>. If you&#8217;ve elected to not load some of the frameworks here they won&#8217;t be available as configuration keys, so you&#8217;ll need to remove them too.</p>
<p>Now a reminder of how the <tt>options</tt> key is defined:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def options
    @@options ||= Hash.new { |h,k| h[k] = ActiveSupport::OrderedOptions.new }
  end
</pre>
</div>
</notextile>

<p>The values for these framework keys are <tt>ActiveSupport::OrderedOptions</tt> objects, with the class defined like this:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
module ActiveSupport #:nodoc:
    class OrderedOptions &lt; OrderedHash
      def []=(key, value)
        super(key.to_sym, value)
      end

      def [](key)
        super(key.to_sym)
      end

      def method_missing(name, *args)
        if name.to_s =~ /(.*)=$/
          self[$1.to_sym] = args.first
        else
          self[name]
        end
      end
    end
  end
</pre>
</div>
</notextile>

<p>We can determine when we call <tt>config.action_view.debug_rjs</tt> it&#8217;s falling back to the <tt>method_missing</tt> defined on <tt>ActiveSupport::OrderedOptions</tt>, which ends up either setting or retrieving a key. In this case because we&#8217;re using a setter, it will set the key for this hash. This completes the loading of <em>config/environments/development.rb</em>.</p>
<h4 id="load_all_active_support">23.2 <tt>load_all_active_support</tt></h4>
<p>This initializer does exactly what it says:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
initializer :load_all_active_support do
    require &quot;active_support/all&quot; unless config.active_support.bare
  end
</pre>
</div>
</notextile>

<p>If you don&#8217;t want this to happen you can specify the <tt>config.active_support.bare</tt> option to <tt>true</tt> in either <em>config/application.rb</em> or any of your environment files.</p>
<h4 id="preload_frameworks">23.3 <tt>preload_frameworks</tt></h4>
<p>Remember earlier how we had all that stuff <tt>eager_autoload</tt>&#8217;d for Active Support?</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
initializer :preload_frameworks do
    require 'active_support/dependencies'
    ActiveSupport::Autoload.eager_autoload! if config.preload_frameworks
  end
</pre>
</div>
</notextile>

<p>This is where it gets loaded. The <tt>eager_autoload!</tt> method is defined like this:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def self.eager_autoload!
    @@autoloads.values.each { |file| require file }
  end
</pre>
</div>
</notextile>

<p>With <tt>@@autoloads</tt> being</p>
<ul>
	<li>load_all_active_support</li>
	<li>preload_frameworks</li>
	<li>initialize_logger</li>
	<li>initialize_cache</li>
	<li>initialize_subscriber</li>
	<li>set_clear_dependencies_hook</li>
	<li>initialize_dependency_mechanism</li>
</ul>
<h4 id="active-support-initializers">23.4 Active Support Initializers</h4>
<p>Active Support</p>
<p><b>Active Support Initializers</b></p>
<ul>
	<li>active_support.initialize_whiny_nils</li>
	<li>active_support.initialize_time_zone</li>
</ul>
<p><b>I18n Initializers</b></p>
<ul>
	<li>i18n.initialize</li>
</ul>
<p>The <tt>I18n::Railtie</tt> also defines an <tt>after_initialize</tt> which we will return to later when discussing the initializers in detail.</p>
<p><b>Action Dispatch Initializers</b></p>
<ul>
	<li>action_dispatch.prepare_dispatcher</li>
</ul>
<p><b>Action Controller Initializers</b></p>
<ul>
	<li>action_controller.logger</li>
	<li>action_controller.set_configs</li>
	<li>action_controller.initialize_framework_caches</li>
	<li>action_controller.set_helpers_path</li>
</ul>
<p><b>Active Record Initializers</b></p>
<ul>
	<li>active_record.initialize_time_zone</li>
	<li>active_record.logger</li>
	<li>active_record.set_configs</li>
	<li>active_record.log_runtime</li>
	<li>active_record.initialize_database_middleware</li>
	<li>active_record.load_observers</li>
	<li>active_record.set_dispatch_hooks</li>
</ul>
<p><strong>Action View Initializers *</strong></p>
<ul>
	<li>action_view.cache_asset_timestamps</li>
</ul>
<p><strong>Action Mailer Initializers *</strong></p>
<ul>
	<li>action_mailer.logger</li>
	<li>action_mailer.set_configs</li>
	<li>action_mailer.url_for</li>
</ul>
<p><b>Active Resource Initializers</b></p>
<ul>
	<li>active_resource.set_configs</li>
</ul>
<p><b>Rails::Engine Initializers</b></p>
<ul>
	<li>set_load_path</li>
	<li>set_autoload_paths</li>
	<li>add_routing_paths</li>
</ul>
<h4 id="rails-engine-new">23.5 <tt>Rails::Engine.new</tt></h4>
<p>The <tt>new</tt> method doesn&#8217;t exist, but in Ruby classes calling <tt>new</tt> on the class instantiates a new instance of that class and calls the instance method <tt>initialize</tt> on it. This method for <tt>Rails::Application</tt> goes like this:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def initialize
     require_environment
     Rails.application ||= self
     @route_configuration_files = []
   end
</pre>
</div>
</notextile>

<h4 id="rails-application-require_environment">23.6 <tt>Rails::Application#require_environment</tt></h4>
<p>This is not a crafty method like the previous ones, it just does as it says on the box:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def require_environment
    require config.environment_path
  rescue LoadError
  end
</pre>
</div>
</notextile>

<p>The <tt>config</tt> object here is actually another <tt>delegate</tt>&#8217;d method (along with <tt>routes</tt>), this time to <tt>self.class</tt>:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
delegate :config, :routes, :to =&gt; :'self.class'
</pre>
</div>
</notextile>

<p>So the method call is actually <tt>self.class.config</tt>.</p>
<h4 id="rails-application-config">23.7 <tt>Rails::Application.config</tt></h4>
<p>Defined back inside the <tt>class << self</tt> for <tt>Rails::Application</tt>, <tt>config</tt> makes a new <tt>Rails::Application::Configuration</tt> object and caches it in a variable called <tt>@config</tt>:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def config
    @config ||= Configuration.new(Plugin::Configuration.default)
  end
</pre>
</div>
</notextile>

<h4 id="rails-plugin-configuration-default">23.8 <tt>Rails::Plugin::Configuration.default</tt></h4>
<p>The <tt>Rails::Plugin::Configuration</tt> class may be a bit difficult to find at first, but if you look for <em>plugin.rb</em> in Rails, you&#8217;ll find it in <em>railties/lib/rails/plugin.rb</em>. In this file, we see the following:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
module Rails
    class Plugin &lt; Railtie
      ...
    end
  end
</pre>
</div>
</notextile>

<p>So we note here that <tt>Rails::Plugin</tt> descends from <tt>Rails::Railtie</tt> and secondly we note that the class <tt>Configuration</tt> is not actually included in the <tt>Plugin</tt> class, but it <b>is</b> in the <tt>Railtie</tt> class!</p>
<h4 id="rails-railtie-configuration">23.9 <tt>Rails::Railtie::Configuration</tt></h4>
<p>We&#8217;ve now tracked down the <tt>Plugin::Configuration.default</tt> method to being <tt>Railtie::Configuration.default</tt>, which is defined like this in <em>railties/lib/rails/configuration.rb</em>:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Railtie::Configuration
    def self.default
      @default ||= new
    end
    ...
  end
</pre>
</div>
</notextile>

<p>In this case we have effectively seen that it&#8217;s doing Configuration.new(Configuration.new). I&#8217;ll explain why.</p>
<h4 id="rails-application-configuration-new">23.10 <tt>Rails::Application::Configuration.new</tt></h4>
<p><span class="caps">TODO</span>: <span class="caps">CLEAN</span> <span class="caps">THIS</span> UP! This subclassing is only temporary and will probably not be separate in Rails 3. This is based solely off what the comment at the top of the Railtie::Configuration class says!</p>
<p>The first thing to note here is that this class is subclassed from <tt>Railtie::Configuration</tt> and therefore the method here is actually <tt>Railtie::Configuration.new</tt>. As mentioned previously, calling <tt>new</tt> will make a new object of this class and then call <tt>initialize</tt> on it, which is defined like this:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def initialize(base = nil)
    if base
      @options    = base.options.dup
      @middleware = base.middleware.dup
    else
      @options    = Hash.new { |h,k| h[k] = ActiveSupport::OrderedOptions.new }
      @middleware = self.class.default_middleware_stack
    end
  end
</pre>
</div>
</notextile>

<p>This method is not called with a <tt>base</tt> argument for <tt>Plugin::Configuration.default</tt> but it is for the <tt>Configuration.new</tt> wrapped around it. We&#8217;ll go for the internal one first, since that&#8217;s the order Rails loads them in.</p>
<h4 id="default_middleware_stack">23.11 <tt>default_middleware_stack</tt></h4>
<p>This method is defined like this:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def self.default_middleware_stack
    ActionDispatch::MiddlewareStack.new.tap do |middleware|
      middleware.use('ActionDispatch::Static', lambda { Rails.public_path }, :if =&gt; lambda { Rails.application.config.serve_static_assets })
      middleware.use('::Rack::Lock', :if =&gt; lambda { !ActionController::Base.allow_concurrency })
      middleware.use('::Rack::Runtime')
      middleware.use('ActionDispatch::ShowExceptions', lambda { ActionController::Base.consider_all_requests_local })
      middleware.use('ActionDispatch::Notifications')
      middleware.use('ActionDispatch::Callbacks', lambda { !Rails.application.config.cache_classes })
      middleware.use('ActionDispatch::Cookies')
      middleware.use(lambda { ActionController::Base.session_store }, lambda { ActionController::Base.session_options })
      middleware.use('ActionDispatch::Flash', :if =&gt; lambda { ActionController::Base.session_store })
      middleware.use('ActionDispatch::ParamsParser')
      middleware.use('::Rack::MethodOverride')
      middleware.use('::ActionDispatch::Head')
    end
  end
</pre>
</div>
</notextile>

<p>To really understand this method we need to dig a little deeper, down into where <tt>ActionDispatch::MiddlewareStack.new</tt> is defined and what in particular it does for us.</p>
<h4 id="actiondispatch-middlewarestack-new">23.12 <tt>ActionDispatch::MiddlewareStack.new</tt></h4>
<p><tt>ActionDispatch</tt> is our first foray outside of the <tt>railties</tt> gem, as this is actually defined in the <tt>actionpack</tt> part of Rails. The class definition is as important as the method:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
module ActionDispatch
    class MiddlewareStack &lt; Array

      ...

      def initialize(*args, &amp;block)
        super(*args)
        block.call(self) if block_given?
      end
    end
  end
</pre>
</div>
</notextile>

<p>When it&#8217;s calling <tt>super</tt> here it&#8217;s actually calling <tt>initialize</tt> on the Array class and from this we can determine that an <tt>ActionDispatch::MiddlewareStack</tt> object is just an <tt>Array</tt> object with special powers. One of those special powers is the ability to take a block, and <tt>call</tt> it with <tt>self</tt>, meaning the block&#8217;s parameter is the object itself!</p>
<h4 id="actiondispatch-middlewarestack-use">23.13 <tt>ActionDispatch::MiddlewareStack.use</tt></h4>
<p>Previously we saw a chunk of code that I&#8217;ll re-show you stripped down:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def self.default_middleware_stack
    ActionDispatch::MiddlewareStack.new.tap do |middleware|
      middleware.use('ActionDispatch::Static', lambda { Rails.public_path }, :if =&gt; lambda { Rails.application.config.serve_static_assets })
      ...
    end
  end
</pre>
</div>
</notextile>

<p>As explained in the previous section, we know that the <tt>new</tt> on <tt>ActionDispatch::MiddlewareStack</tt> takes a block and that block has one parameter which is the object itself. On this object we call the <tt>use</tt> method to include middleware into our application. The use method simply does this:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def use(*args, &amp;block)
    middleware = Middleware.new(*args, &amp;block)
    push(middleware)
  end
</pre>
</div>
</notextile>

<p>We&#8217;ll come back to this method later on.</p>
<h4 id="actioncontroller-middleware-new">23.14 <tt>ActionController::Middleware.new</tt></h4>
<p>This <tt>initialize</tt> method also is in a class who&#8217;s ancestry is important so once again I&#8217;ll show the ancestry and we&#8217;ll go up that particular chain:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
module ActionController
    class Middleware &lt; Metal

    ...

      def initialize(app)
        super()
        @_app = app
      end
    end
  end
</pre>
</div>
</notextile>

<p>Here our method calls <tt>super</tt> but with a difference: it&#8217;s passing in no arguments intentionally by putting the two brackets at the end. The method called here is therefore <tt>ActionController::Metal.initialize</tt>.</p>
<h4 id="actioncontroller-metal-initialize">23.15 <tt>ActionController::Metal.initialize</tt></h4>
<p>This is another subclassed class, this time from <tt>ActionController::AbstractController</tt> and I&#8217;m sure you can guess what that means:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Metal &lt; AbstractController::Base

    ...

    def initialize(*)
      @_headers = {}
      super
    end
  end
</pre>
</div>
</notextile>

<p>The single <tt>*</tt> in the argument listing means we can accept any number of arguments, we just don&#8217;t care what they are.</p>
<h4 id="abstractcontroller-base-initialize">23.16 <tt>AbstractController::Base.initialize</tt></h4>
<p>This may be anti-climatic, but the initialize method here just returns an <tt>AbstractController::Base</tt> object:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
# Initialize controller with nil formats.
  def initialize #:nodoc:
    @_formats = nil
  end
</pre>
</div>
</notextile>

<h4 id="actiondispatch-middlewarestack-use">23.17 <tt>ActionDispatch::MiddlewareStack.use</tt></h4>
<p>Now we&#8217;re back to this method, from our foray into the depths of how <tt>Middleware.new</tt> works, we&#8217;ve showed that it is an instance of <tt>AbstractController::Base</tt>. Therefore it does</p>
<p><span class="caps">TODO</span>: <span class="caps">ELABORATE</span> ON <span class="caps">THIS</span> <span class="caps">SECTION</span>, including explaining what all the pieces of middleware do. Then explain how the default_middleware_stack does what it does, whatever that is.</p>
<h4 id="back-to-rails-application-configuration-new">23.18 Back to <tt>Rails::Application::Configuration.new</tt></h4>
<p>Now that the first call to this method is complete (<tt>Plugin::Configuration.default</tt>), we can move onto the second call. Here&#8217;s a refresher of what this method does:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def initialize(base = nil)
    if base
      @options    = base.options.dup
      @middleware = base.middleware.dup
    else
      @options    = Hash.new { |h,k| h[k] = ActiveSupport::OrderedOptions.new }
      @middleware = self.class.default_middleware_stack
    end
  end
</pre>
</div>
</notextile>

<p>You&#8217;ll note now that this method is being called now is <tt>Configuration.new(Plugin::Configuration.default)</tt> and with the argument, it&#8217;s going to perform differently than before, this time duplicating the <tt>options</tt> and <tt>middleware</tt> of the object it was passed.</p>
<p><span class="caps">TODO</span>: Find out what purpose the <tt>@options</tt> and <tt>@middleware</tt> variables serve.</p>
<p>Finally, a <tt>Rails::Application::Configuration</tt> object will be returned. On this class there are a couple of <tt>attr_accessor</tt>s and <tt>attr_writer</tt>s defined:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
attr_accessor :after_initialize_blocks, :cache_classes, :colorize_logging,
                :consider_all_requests_local, :dependency_loading,
                :load_once_paths, :logger, :plugins,
                :preload_frameworks, :reload_plugins, :serve_static_assets,
                :time_zone, :whiny_nils

  attr_writer :cache_store, :controller_paths,
              :database_configuration_file, :eager_load_paths,
              :i18n, :load_paths, :log_level, :log_path, :paths,
              :routes_configuration_file, :view_path
</pre>
</div>
</notextile>

<p>Along with these are a lot of helper methods, and one of them is <tt>environment_path</tt>:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def environment_path
    &quot;#{root}/config/environments/#{Rails.env}.rb&quot;
  end
</pre>
</div>
</notextile>

<h4 id="back-to-rails-application-require_environment">23.19 Back to <tt>Rails::Application#require_environment</tt></h4>
<p>Now that we have a <tt>Rails::Application::Configuration</tt> object for the <tt>config</tt> method, we call the <tt>environment_path</tt> which, as we&#8217;ve seen above, just requires the current environment file which in this case is <em>config/environments/development.rb</em>. If this file cannot be found, the <tt>LoadError</tt> <tt>require</tt> throws will be <tt>rescue</tt>&#8217;d and Rails will continue on its merry way.</p>
<h4 id="_config-environments-development-rb_">23.20 <em>config/environments/development.rb</em></h4>
<p>In a standard Rails application we have this in our <em>config/environments/development.rb</em> file:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
YourApp::Application.configure do
    # Settings specified here will take precedence over those in config/environment.rb

    # In the development environment your application's code is reloaded on
    # every request.  This slows down response time but is perfect for development
    # since you don't have to restart the webserver when you make code changes.
    config.cache_classes = false

    # Log error messages when you accidentally call methods on nil.
    config.whiny_nils = true

    # Show full error reports and disable caching
    config.action_controller.consider_all_requests_local = true
    config.action_view.debug_rjs                         = true
    config.action_controller.perform_caching             = false

    # Don't care if the mailer can't send
    config.action_mailer.raise_delivery_errors = false
  end
</pre>
</div>
</notextile>

<p>It&#8217;s a little bit sneaky here, but <tt>configure</tt> is <tt>alias</tt>&#8216;d to <tt>class_eval</tt> on subclasses of <tt>Rails::Application</tt> which of course includes <tt>YourApp::Application</tt>. This means that the code inside the <tt>configure do</tt> block will be evaled within the context of <tt>YourApp::Application</tt>. The <tt>config</tt> method here is the one mentioned before: the <tt>Rails::Application::Configuration</tt> object. The methods on it should look familiar too: they&#8217;re the ones that had <tt>attr_accessor</tt> and <tt>attr_writer</tt> definitions.</p>
<p>The ones down the bottom, <tt>config.action_controller</tt>, <tt>config.action_view</tt> and <tt>config.action_mailer</tt> aren&#8217;t defined by <tt>attr_accessor</tt> or <tt>attr_writer</tt>, rather they&#8217;re undefined methods and therefore will trigger the <tt>method_missing</tt> on the <tt>Rails::Application::Configuration</tt> option.</p>
<h5 id="config-cache_classes">23.20.1 config.cache_classes=</h5>
<p>The first method call in this file, this tells Rails to not cache the classes for every request. This means for every single request Rails will reload the classes of your application. If you have a lot of classes, this will slow down the request cycle of your application. This is set to <tt>false</tt> in the <em>development</em> environment, and <tt>true</tt> in the <em>test</em> &amp; <em>production</em> environments.</p>
<h5 id="config-whiny_nils">23.20.2 config.whiny_nils=</h5>
<p>If this is set to <tt>true</tt>, like it is here in the <em>development</em> environment, <em>activesupport/whiny_nil</em> will be <tt>require</tt>&#8217;d. Have you ever seen this error:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Called id for nil, which would mistakenly be 4 -- if you really wanted the id of nil, use object_id
</pre>
</div>
</notextile>

<p>Or perhaps this one?</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
You have a nil object when you didn't expect it!
  You might have expected an instance of Array.
  The error occurred while evaluating nil.flatten!
</pre>
</div>
</notextile>

<p>If you have, then this is <em>activesupport/whiny_nil</em> at work.</p>
<h5 id="the-frameworks">23.20.3 The frameworks</h5>
<p>As mentioned before, the methods <tt>action_controller</tt>, <tt>action_view</tt> and <tt>action_mailer</tt> aren&#8217;t defined on the <tt>Rails::Application::Configuration</tt> object, rather they are caught by <tt>method_missing</tt> which does this:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def method_missing(name, *args, &amp;blk)
    if name.to_s =~ config_key_regexp
      return $2 == '=' ? @options[$1] = args.first : @options[$1]
    end

    super
  end
</pre>
</div>
</notextile>

<p>Whilst this code is not obvious at first, a little bit of further explanation will help you understand. <tt>config_key_regexp</tt> is another method (a private one, like <tt>method_missing</tt>) defined here:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def config_key_regexp
    bits = config_keys.map { |n| Regexp.escape(n.to_s) }.join('|')
    /^(#{bits})(?:=)?$/
  end
</pre>
</div>
</notextile>

<p>As is <tt>config_keys</tt>:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def config_keys
    ([ :active_support, :action_view ] +
      Railtie.plugin_names).map { |n| n.to_s }.uniq
  end
</pre>
</div>
</notextile>

<p>Aha! There we&#8217;ve got mention of <tt>action_view</tt>, but what is in <tt>Railtie.plugin_names</tt>? Most likely in this case the other frameworks.</p>
<h5 id="railtie-plugin_names">23.20.4 <tt>Railtie.plugin_names</tt></h5>
<p>I&#8217;m going to show you two methods since the third one, <tt>self.plugin_name</tt>, calls the second one, <tt>self.plugins</tt> and they&#8217;re right after each other:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
module Rails
    class Railtie
      def self.inherited(klass)
        @plugins ||= []
        @plugins &lt;&lt; klass unless klass == Plugin
      end

      def self.plugins
        @plugins
      end

      def self.plugin_names
        plugins.map { |p| p.plugin_name }
      end
    end
  end
</pre>
</div>
</notextile>

<p>In here we see that we get the <tt>plugin_names</tt> from a variable called <tt>@plugins</tt>&#8230; which we haven&#8217;t seen yet. Through the power of the wonderful <tt>inherited</tt> the <tt>@plugins</tt> variable is populated. <tt>inherited</tt> is called when a class inherits, or subclasses, from this class. Therefore we can determine that the other classes are probably inheriting or subclassing from <tt>Rails::Railtie</tt>.</p>
<h3 id="serving-a-request">24 Serving a Request</h3>
<p>Now that your application is fully initialized, it&#8217;s now ready to start serving requests.</p>
<h4 id="_rails-server_">24.1 <em>rails server</em></h4>
<p>For servers running through <em>rails server</em> you may recall that this uses <tt>Rails::Server</tt> which is a subclass of <tt>Rack::Server</tt>. Previously we covered the initialization process of Rack but not completely up to the point where the server was running. Now that&#8217;s what we&#8217;ll do. Back when the <tt>Rack::Server</tt> class was first covered there was a mention of the <tt>start</tt> method which we only touched on. It goes a little like this:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def start
    if options[:debug]
      $DEBUG = true
      require 'pp'
      p options[:server]
      pp wrapped_app
      pp app
    end

    if options[:warn]
      $-w = true
    end

    if includes = options[:include]
      $LOAD_PATH.unshift *includes
    end

    if library = options[:require]
      require library
    end

    daemonize_app if options[:daemonize]
    write_pid if options[:pid]
    server.run wrapped_app, options
  end
</pre>
</div>
</notextile>

<p>We were at the point of explaining what <tt>wrapped_app</tt> was before we dived into the Rails initialization process.Now that we have a <tt>wrapped_app</tt> we pass it as the first argument to <tt>server.run</tt>. <tt>server</tt> in this instance is defined like this:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def server
    @_server ||= Rack::Handler.get(options[:server]) || Rack::Handler.default
  end
</pre>
</div>
</notextile>

<p>Our <tt>options</tt> Hash is still the default, and there is no <tt>server</tt> key set in <tt>default_options</tt>, so it will default to <tt>Rack::Handler.default</tt>. This code works like this:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def self.default(options = {})
    # Guess.
    if ENV.include?(&quot;PHP_FCGI_CHILDREN&quot;)
      # We already speak FastCGI
      options.delete :File
      options.delete :Port

      Rack::Handler::FastCGI
    elsif ENV.include?(&quot;REQUEST_METHOD&quot;)
      Rack::Handler::CGI
    else
      begin
        Rack::Handler::Mongrel
      rescue LoadError =&gt; e
        Rack::Handler::WEBrick
      end
    end
  end
</pre>
</div>
</notextile>

<p>We don&#8217;t have <tt>PHP_FCGI_CHILDREN</tt> in our <tt>ENV</tt>, so it&#8217;s not going to be <tt>FastCGI</tt>. We also don&#8217;t have <tt>REQUEST_METHOD</tt> in there, so it&#8217;s not going to be <tt>CGI</tt>. If we have Mongrel installed it&#8217;ll default to that and then finally it&#8217;ll use WEBrick. For this, we&#8217;ll assume a bare-bones installation and assume WEBrick. So from this we can determine our default handler is <tt>Rack::Handler::WEBrick</tt>.</p>
<p>(side-note: Mongrel doesn&#8217;t install on 1.9. <span class="caps">TODO</span>: How do we format these anyway?)</p>
<h5 id="rack-handler-webrick">24.1.1 <tt>Rack::Handler::WEBrick</tt></h5>
<p>This class is subclassed from <tt>WEBrick::HTTPServlet::AbstractServlet</tt> which is a class that comes with the Ruby standard library. This is the magical class that serves the requests and deals with the comings (requests) and goings (responses) for your server.</p>
<p><tt>Rack::Server</tt> has handlers for the request and by default the handler for a <em>rails server</em> server is</p>
<h3 id="cruft">25 Cruft!</h3>
<p>The final line of <em>config/environment.rb</em>:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
YourApp::Application.initialize!
</pre>
</div>
</notextile>

<p>gets down to actually initializing the application!</p>
<p><span class="caps">TODO</span>: Cover the other <tt>config.*</tt> methods in perhaps a &#8220;Bonus&#8221; section near the end. If they aren&#8217;t referenced in a config file they aren&#8217;t that important, right?</p>
<p><span class="caps">TODO</span>: This belongs in the guide, I just don&#8217;t know where yet. Maybe towards the end, since this is really the &#8220;final&#8221; thing to be done before being able to serve requests.</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def build_app(app)
    middleware[options[:environment]].reverse_each do |middleware|
      middleware = middleware.call(self) if middleware.respond_to?(:call)
      next unless middleware
      klass = middleware.shift
      app = klass.new(app, *middleware)
    end
    app
  end
</pre>
</div>
</notextile>

<p>Because we don&#8217;t have any middleware for our application, this returns the application itself( Guessing here!! <span class="caps">TODO</span>: Investigate if this is really the case.)</p>
<p>Now that we have an app instance, the last line in <tt>start</tt> calls <tt>server.run wrapped_app, options</tt>. We know what our app is, and that our options are just the default options, so what is <tt>server</tt>? <tt>server</tt> is this:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def server
    @_server ||= Rack::Handler.get(options[:server]) || Rack::Handler.default
  end
</pre>
</div>
</notextile>

<p>Since we have default options, the server is obviously going to be <tt>Rack::Handler.default</tt>. The <tt>default</tt> method goes like this:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def self.default(options = {})
    # Guess.
    if ENV.include?(&quot;PHP_FCGI_CHILDREN&quot;)
      # We already speak FastCGI
      options.delete :File
      options.delete :Port

      Rack::Handler::FastCGI
    elsif ENV.include?(&quot;REQUEST_METHOD&quot;)
      Rack::Handler::CGI
    else
      begin
        Rack::Handler::Mongrel
      rescue LoadError =&gt; e
        Rack::Handler::WEBrick
      end
    end
  end
</pre>
</div>
</notextile>

<h3 id="rails-paths">26 <tt>Rails::Paths</tt></h3>
<p>The <tt>super</tt> method it references comes from <tt>Rails::Engine::Configuration</tt> which defines these paths:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def paths
    @paths ||= begin
      paths = Rails::Paths::Root.new(@root)
      paths.app                 &quot;app&quot;,                 :eager_load =&gt; true, :glob =&gt; &quot;*&quot;
      paths.app.controllers     &quot;app/controllers&quot;,     :eager_load =&gt; true
      paths.app.helpers         &quot;app/helpers&quot;,         :eager_load =&gt; true
      paths.app.models          &quot;app/models&quot;,          :eager_load =&gt; true
      paths.app.views           &quot;app/views&quot;
      paths.lib                 &quot;lib&quot;,                 :load_path =&gt; true
      paths.lib.tasks           &quot;lib/tasks&quot;,           :glob =&gt; &quot;**/*.rake&quot;
      paths.lib.templates       &quot;lib/templates&quot;
      paths.config              &quot;config&quot;
      paths.config.initializers &quot;config/initializers&quot;, :glob =&gt; &quot;**/*.rb&quot;
      paths.config.locales      &quot;config/locales&quot;,      :glob =&gt; &quot;*.{rb,yml}&quot;
      paths.config.routes       &quot;config/routes.rb&quot;
      paths
    end
  end
</pre>
</div>
</notextile>

<h3 id="appendix-a">27 Appendix A</h3>
<p>This file is <em>activesupport/lib/active_support/inflector/inflections.rb</em> and defines the <tt>ActiveSupport::Inflector::Inflections</tt> class which defines the <tt>singularize</tt>, <tt>pluralize</tt>, <tt>humanize</tt>, <tt>tableize</tt>, <tt>titleize</tt> and <tt>classify</tt> methods as well as the code to defining how to work out the irregular, singular, plural and human versions of words. These methods are called <tt>irregular</tt>, <tt>singular</tt>, <tt>plural</tt> and <tt>human</tt> respectively, as is the Rails way.</p>
<p>This file is <em>activesupport/lib/active_support/inflector/transliterate.rb</em> and defines two methods, <tt>transliterate</tt> and <tt>parameterize</tt>.</p>
<p>This file first requires <em>activesupport/lib/active_support/core_ext/string/multibyte.rb</em>, which requires <em>activesupport/lib/active_support/multibyte.rb</em>, which subsequently requires <em>activesupport/core_ext/module/attribute_accessors.rb</em>. The <em>attribute_accessors.rb</em> file is needed to gain access to the <tt>mattr_accessor</tt> (module attribute accessor) method, which is called in <em>active_suport/multibyte.rb</em>. The file <em>active_support/multibyte.rb</em> also autoloads three other classes:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
module ActiveSupport #:nodoc:
  module Multibyte
    autoload :EncodingError, 'active_support/multibyte/exceptions'
    autoload :Chars, 'active_support/multibyte/chars'
    autoload :Unicode, 'active_support/multibyte/unicode'
    ...
  end
end
</pre>
</div>
</notextile>

<p>There are also these method definitions:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
# The proxy class returned when calling mb_chars. You can use this accessor to configure your own proxy
  # class so you can support other encodings. See the ActiveSupport::Multibyte::Chars implementation for
  # an example how to do this.
  #
  # Example:
  #   ActiveSupport::Multibyte.proxy_class = CharsForUTF32
  def self.proxy_class=(klass)
    @proxy_class = klass
  end

  # Returns the currect proxy class
  def self.proxy_class
    @proxy_class ||= ActiveSupport::Multibyte::Chars
  end
</pre>
</div>
</notextile>

<p>These methods are used in <em>activesupport/lib/active_support/core_ext/string/multibyte.rb</em>.</p>
<p>The file <em>activesupport/lib/active_support/core_ext/string/chars.rb</em>  defines the default proxy class that will be returned by <tt>mb_chars</tt>.</p>
<p>Because Ruby 1.9&#8217;s <tt>String</tt> class has support for multibyte encodings, some methods are defined only for Ruby 1.8:</p>
<ul>
	<li><tt>self.wants?</tt></li>
	<li><tt></tt>+</li>
	<li><tt>=~</tt></li>
	<li><tt>=~</tt></li>
	<li><tt>center</tt></li>
	<li><tt>include?</tt></li>
	<li><tt>index</tt></li>
	<li><tt>insert</tt></li>
	<li><tt>ljust</tt></li>
	<li><tt>lstrip</tt>, <tt>lstrip!</tt></li>
	<li><tt>ord</tt></li>
	<li><tt>rindex</tt></li>
	<li><tt>rjust</tt></li>
	<li><tt>rstrip</tt>, <tt>rstrip!</tt></li>
	<li><tt>size</tt></li>
	<li><tt>strip</tt>, <tt>strip!</tt></li>
</ul>
<p>However, Ruby 1.9 lacks support for some needed operations, so the following methods are defined for both Ruby 1.8 and Ruby 1.9:</p>
<ul>
	<li><tt><=></tt></li>
	<li><tt>[]=</tt></li>
	<li><tt>capitalize</tt>, <tt>capitalize!</tt></li>
	<li><tt>compose</tt></li>
	<li><tt>decompose</tt></li>
	<li><tt>downcase</tt>, <tt>downcase!</tt></li>
	<li><tt>g_length</tt></li>
	<li><tt>limit</tt></li>
	<li><tt>normalize</tt></li>
	<li><tt>reverse</tt>, <tt>reverse</tt>!</li>
	<li><tt>slice</tt>, <tt>slice!</tt></li>
	<li><tt>split</tt></li>
	<li><tt>tidy_bytes</tt>, <tt>tidy_bytes!</tt></li>
	<li><tt>titleize</tt></li>
	<li><tt>upcase</tt>, <tt>upcase!</tt></li>
</ul>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class String
    if RUBY_VERSION &gt;= &quot;1.9&quot;
      def mb_chars
        if ActiveSupport::Multibyte.proxy_class.consumes?(self)
          ActiveSupport::Multibyte.proxy_class.new(self)
        else
          self
        end
      end

      def is_utf8? #:nodoc
        case encoding
        when Encoding::UTF_8
          valid_encoding?
        when Encoding::ASCII_8BIT, Encoding::US_ASCII
          dup.force_encoding(Encoding::UTF_8).valid_encoding?
        else
          false
        end
      end
    else
      def mb_chars
        if ActiveSupport::Multibyte.proxy_class.wants?(self)
          ActiveSupport::Multibyte.proxy_class.new(self)
        else
          self
        end
      end

      # Returns true if the string has UTF-8 semantics (a String used for purely byte resources is unlikely to have
      # them), returns false otherwise.
      def is_utf8?
        ActiveSupport::Multibyte::Chars.consumes?(self)
      end
    end
</pre>
</div>
</notextile>

<p>As you can see, <tt>mb_chars</tt> is where the <tt>proxy_class</tt> property comes in handy. This method will create a new instance of the configured proxy class using the instance of <tt>String</tt> as a constructor argument. By default, the new <tt>String</tt>-like object will be an instance of the proxy class <tt>ActiveSupport::Multibyte::Chars</tt>. You can use <tt>ActiveSupport::Multibyte.proxy_class=</tt> to set a different proxy class if you wish.</p>
<p>Here, <tt>mb_chars</tt> invokes <tt>is_utf8?</tt> to checks if the string can be treated as <span class="caps">UTF</span>-8. On 1.9, the string&#8217;s <tt>encoding</tt> property is checked. On 1.8, <tt>wants?</tt> checks to see if <tt>$KCODE</tt> is &#8220;<span class="caps">UTF</span>-8&#8221; and, and <tt>consumes?</tt> checks whether the string can be unpacked as <span class="caps">UTF</span>-8 without raising an error.</p>
<p>The keen eye will have seen <tt>ActiveSupport::Multibyte::Chars</tt> was specified as an <tt>autoload</tt> earlier: <em>activesupport/lib/active_support/multibyte/chars.rb</em> will be loaded without an explicit <tt>require</tt> when we call <tt>is_utf8</tt> on 1.8, or <tt>mb_chars</tt> on any Ruby version. This file includes <em>activesupport/lib/active_support/string/access.rb</em> which defines methods such as <tt>at</tt>, <tt>from</tt>, <tt>to</tt>, <tt>first</tt> and <tt>last</tt>. These methods will return parts of the string depending on what is passed to them.</p>
<p>The second file included is <em>activesupport/lib/active_support/string/behavior.rb</em> which only defines  <tt>acts_like_string?</tt> on <tt>String</tt>, a method which always returns <tt>true</tt>. This method is used by <tt>Object#acts_like?</tt>, which accepts a single argument representing the downcased and symbolised version of a class, and returns true if the object&#8217;s behavior is like that class. In this case the code would be <tt>acts_like?(:string)</tt>.</p>
<p>The <tt>Chars</tt> class also defines other important methods such as the &#8220;spaceship&#8221; method <tt><=></tt>, which is needed by the <tt>Comparable</tt> module, in order to allow <span class="caps">UTF</span>-8-aware sorting.</p>
<h3 id="common-includes">28 Common Includes</h3>
<p><span class="caps">TODO</span>: I feel this section would be better at the end of the guide as it breaks the flow.</p>
<p>This section is for all the common includes in the Railties.</p>
<h4 id="require-active_support-inflector">28.1 <tt>require 'active_support/inflector'</tt></h4>
<p>This file is <em>activesupport/lib/active_support/inflector.rb</em> and makes a couple of requires out different files tasked with putting inflections in place:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require 'active_support/inflector/inflections'
  require 'active_support/inflector/transliterate'
  require 'active_support/inflector/methods'

  require 'active_support/inflections'
  require 'active_support/core_ext/string/inflections'
</pre>
</div>
</notextile>

<p>The files included here define methods for modifying strings, such as <tt>transliterate</tt> which will convert a Unicode string to its <span class="caps">ASCII</span> version, <tt>parameterize</tt> for making strings into url-safe versions, <tt>camelize</tt> for camel-casing a string such as <tt>string_other</tt> into <tt>StringOther</tt> and <tt>ordinalize</tt> converting a string such as <tt>101</tt> into <tt>101st</tt>. More information about these methods can be found in the Active Support Core Extensions Guide. <span class="caps">TODO</span>: Link to AS Guide.</p>
<h4 id="require-active_support-core_ext-module-delegation">28.2 <tt>require 'active_support/core_ext/module/delegation'</tt></h4>
<p><em>activesupport/lib/active_support/core_ext/module/delegation.rb</em> defines the <tt>delegate</tt> method which can be used to delegate methods to other methods in your code. Take the following code example:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Client &lt; ActiveRecord::Base
    has_one :address

    delegate :address_line_1, :to =&gt; :address
  end
</pre>
</div>
</notextile>

<p>This defines an <tt>address_line_1</tt> method which is defined as:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def address_line_1(*args, &amp;block)
    address.__send__(:address_line_1, *args, &amp;block)
    rescue NoMethodError
      if address.nil?
        raise &quot;address_line_1 is delegated to address.address_line_1, but address is nil: #{client.inspect}&quot;
      end
  end
</pre>
</div>
</notextile>

<h4 id="require-active_support-core_ext-class-attribute_accessors">28.3 <tt>require 'active_support/core_ext/class/attribute_accessors'</tt></h4>
<p>The file, <em>activesupport/lib/active_support/core_ext/class/attribute_accessors.rb_, defines the class accessor methods <tt>cattr_writer</tt>, <tt>cattr_reader</tt> and <tt>cattr_accessor</tt>. <tt>cattr_accessor</tt> defines a <tt>cattr_reader</tt> and <tt>cattr</em>writer</tt></notextile> for the symbol passed in. These methods work by defining class variables when you call their dynamic methods.</p>
<p>Throughout the Railties there a couple of common includes. They are listed here for your convenience.</p>
<h4 id="require-active_support-core_ext-module-attr_internal">28.4 <tt>require 'active_support/core_ext/module/attr_internal</tt></h4>
<p>This file defines three methods <tt>attr_internal_reader</tt>, <tt>attr_internal_writer</tt> and <tt>attr_internal_accessor</tt>. These work very similar to the <tt>attr_reader</tt>, <tt>attr_writer</tt> and <tt>attr_accessor</tt> methods, except the variables they define begin with <tt>@_</tt>. This was done to ensure that they do not clash with variables used people using Rails, as people are less-likely to define say, <tt>@_request</tt> than they are to define <tt>@request</tt>. An example of where this method is used is for <tt>params</tt> in the <tt>ActionController::Metal</tt> class.</p>
<h4 id="require-active_support-ruby-shim">28.5 <tt>require 'active_support/ruby/shim'</tt></h4>
<p>The <em>activesupport/lib/active_support/ruby/shim.rb</em> file requires methods that have been implemented in Ruby versions greater than 1.9. This is done so you can use Rails 3 on versions earlier than 1.9, such as 1.8.7. These methods are:</p>
<ul>
	<li><tt>Date#next_month</tt></li>
	<li><tt>Date#next_year</tt></li>
	<li><tt>DateTime#to_date</tt></li>
	<li><tt>DateTime#to_datetime</tt></li>
	<li><tt>DateTime#xmlschema</tt></li>
	<li><tt>Enumerable#group_by</tt></li>
	<li><tt>Enumerable#each_with_object</tt></li>
	<li><tt>Enumerable#none?</tt></li>
	<li><tt>Process#daemon</tt></li>
	<li><tt>String#ord</tt></li>
	<li><tt>Time#to_date</tt></li>
	<li><tt>Time.to_time</tt></li>
	<li><tt>Time.to_datetime</tt></li>
</ul>
<p>For more information see the Active Support Core Extensions guide <span class="caps">TODO</span>: link to relevant sections for each method.</p>
<p>And <a href="[http://weblog.rubyonrails.org/2008/8/23/dos-vulnerabilities-in-rexml">the <span class="caps">REXML</span> security fix detailed here</a>]</p>
        
        <h3>Feedback</h3>
        <p>
          You're encouraged to help in keeping the quality of this guide.
        </p>
        <p>
          If you see any typos or factual errors you are confident to
          patch please clone <a href="https://github.com/lifo/docrails">docrails</a>
          and push the change yourself. That branch of Rails has public write access.
          Commits are still reviewed, but that happens after you've submitted your
          contribution. <a href="https://github.com/lifo/docrails">docrails</a> is
          cross-merged with master periodically.
        </p>
        <p>
          You may also find incomplete content, or stuff that is not up to date.
          Please do add any missing documentation for master. Check the
          <a href="ruby_on_rails_guides_guidelines.html">Ruby on Rails Guides Guidelines</a>
          guide for style and conventions.
        </p>
        <p>
          Issues may also be reported <a href="https://github.com/lifo/docrails/issues">in Github</a>.
        </p>
        <p>And last but not least, any kind of discussion regarding Ruby on Rails
          documentation is very welcome in the <a href="http://groups.google.com/group/rubyonrails-docs">rubyonrails-docs mailing list</a>.
        </p>
      </div>
    </div>
  </div>

  <hr class="hide" />
  <div id="footer">
    <div class="wrapper">
      <p>This work is licensed under a <a href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-Share Alike 3.0</a> License</p>
      <p>"Rails", "Ruby on Rails", and the Rails logo are trademarks of David Heinemeier Hansson. All rights reserved.</p>
    </div>
  </div>

  <script type="text/javascript" src="javascripts/guides.js"></script>
  <script type="text/javascript" src="javascripts/syntaxhighlighter/shCore.js"></script>
  <script type="text/javascript" src="javascripts/syntaxhighlighter/shBrushRuby.js"></script>
  <script type="text/javascript" src="javascripts/syntaxhighlighter/shBrushXml.js"></script>
  <script type="text/javascript" src="javascripts/syntaxhighlighter/shBrushSql.js"></script>
  <script type="text/javascript" src="javascripts/syntaxhighlighter/shBrushPlain.js"></script>
  <script type="text/javascript">
    SyntaxHighlighter.all()
  </script>
</body>
</html>
